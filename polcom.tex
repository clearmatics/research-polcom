% !TeX spellcheck = en_UK
% \let\accentvec\vec              
\documentclass[runningheads,11pt]{llncs}
%\let\spvec\vec \let\vec\accentvec
\newcommand\hmmax{0}
\newcommand\bmmax{0}

\usepackage{amssymb,amsmath}
%\let\vec\spvec
%\usepackage{lmodern}
\usepackage{newtxmath,newtxtext}
\usepackage[T1]{fontenc}
% \def\vec#1{\mathchoice{\mbox{\mathbf$\displaystyle#1$}}
% {\mbox{\mathbf$\textstyle#1$}} {\mbox{\mathbf$\scriptstyle#1$}}
% {\mbox{\mathbf$\scriptscriptstyle#1$}}}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{<-> mathx10}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathAccent{\widebar}{0}{mathx}{"73}

\usepackage{soulutf8} \soulregister\cite7 \soulregister\ref7
\soulregister\pageref7 \usepackage{hyperref}
\usepackage[color=yellow]{todonotes} \hypersetup{final} \usepackage{mathrsfs}
\usepackage[advantage,asymptotics,adversary,sets,keys,ff,lambda,primitives,events,operators,probability,logic,mm,complexity]{cryptocode}

\usepackage{cite} 
\usepackage{booktabs}
\usepackage{paralist}
\usepackage[innerleftmargin=5pt,innerrightmargin=5pt]{mdframed}
\usepackage{caption}
\captionsetup{belowskip=0pt}
\usepackage{bm}
\usepackage{url}
%\usepackage{dirtytalk}
\newcommand{\say}[1]{\emph{``#1''}}
\usepackage[margin=0.7in,a4paper]{geometry}
\usepackage[normalem]{ulem}
\usepackage{dashbox}
\newcommand{\dboxed[1]}{\dbox{\ensuremath{#1}}}
\usepackage{hyperref}
\usepackage[capitalise]{cleveref}

%\usepackage{mathptmx}

\include{macros}

\title{On PIOP-based zkSNARKs}

\author{} 
%\iflncs{
\institute{} 

\allowdisplaybreaks

\begin{document} \sloppy \maketitle

\begin{abstract}
  In this paper we investigate properties of zkSNARKs obtained by
  compiling a PIOP proof using a polynomial commitment scheme. The question we
  try to answer is \say{What polynomial commitment's properties propagate to
    the resulting zkSNARK?}. The properties we focus on are:
  \begin{compactenum}
  \item simulation extractability,
  \item SRS updatability,
  \item SRS-updatable simulation extractability,
  \item subversion zero knowledge.
  \end{compactenum}
  The research hypothesis is \say{A NIZK obtained from a simulation extractable /
    SRS-updatable / SRS updatable SE / subversion zero knowledge polynomial
    commitment is simulation extractable /
    SRS-updatable / SRS updatable SE / subversion zero knowledge.} To be able to
  show the hypothesis we need to solve a number of problems
  \begin{compactenum}
  \item Neither simulation extractability, SRS-updatability, SRS-updatable
    simulation extractability, nor subversion zero knowledge have been defined
    for a polynomial commitment scheme. Another contribution of the paper is
    defining these properties. 
  \item Similarly, there is no definition for SRS-updatable simulation
    extractable NIZKs.
  \item The polynomial IOP is defined very generally, cf.~\cref{def:piop}, what
    makes showing generic properties difficult. The paper would propose tighter
    definitions which would emphasize more the structure of PIOP,
    but would not narrow a class of possible (from the practical point of view)
    PIOPs too much, cf.~\cref{def:wepiop,def:sdwepiop}.
  \end{compactenum}
  
\end{abstract}

\section{Preliminaries}
\paragraph{Polynomial commitment scheme.}
\label{sec:poly_com}
In the polynomial commitment scheme $\PCOM = (\kgen, \com, \open, \verify)$ the
prover $\prover$ convinces the verifier $\verifier$ that some polynomial $\p{f}$
which $\prover$ committed to evaluates to $s$ at some point $z$ chosen by
$\verifier$.  The key generation algorithm $\kgen$ takes as input a security
parameter $\secparam$ and a parameter $\maxdeg$ which determines the maximal
degree of the committed polynomial. We assume that $\maxdeg$ can be read from
the output SRS.
  
We emphasize the following properties of a secure polynomial commitment
$\PCOM$:
\begin{description}
\item[Evaluation binding:] A $\ppt$ adversary $\adv$ which outputs a commitment
  $\vec{c}$ and evaluation points $\vec{z}$ has at most negligible chances to
  open the commitment to two different evaluations $\vec{s}, \vec{s'}$. That is,
  let $k \in \NN$ be the number of committed polynomials, $l \in \NN$ number of
  evaluation points, $\vec{c} \in \GRP^k$ be the commitments,
  $\vec{z} \in \FF_p^l$ be the arguments the polynomials are evaluated at,
  $\vec{s},\vec{s}' \in \FF_p^k$ the evaluations, and
  $\vec{o},\vec{o}' \in \FF_p^l$ be the commitment openings. Then for every
  $\ppt$ adversary $\adv$
	\[
		\Pr
			\left[
			\begin{aligned}
				& \verify(\srs, \vec{c}, \vec{z}, \vec{s}, \vec{o}) = 1,  \\ 
				& \verify(\srs, \vec{c}, \vec{z}, \vec{s}', \vec{o}') = 1, \\
				& \vec{s} \neq \vec{s}'
			\end{aligned}
			\,\left|\,\vphantom{\begin{aligned}
                  & \\
                  & \\
                  &
                \end{aligned}}
			\begin{aligned}
				& \srs \gets \kgen(\secparam, \maxdeg),\\
				& (\vec{c}, \vec{z}, \vec{s}, \vec{s}', \vec{o}, \vec{o}') \gets \adv(\srs)
			\end{aligned}
			\right.\right] \leq \negl\,.
	\]

\end{description}
	

\begin{description}
\item[Commitment of knowledge] For every $\ppt$ adversary
  $\adv = (\adv_1, \adv_2)$ who produces commitment $c$, gets random evaluation
  point $z$, and outputs evaluation $s$ with an opening $o$ there exists a
  $\ppt$ extractor $\ext$ such that
\[
  \Pr \left[
    \begin{aligned}
      & \p{f} = \ext_\adv(\srs, c, (r_1, r_2)),\\
      & c = \com(\srs, \p{f}),\\
      & \verify(\srs, c, z, s, o) = 1
    \end{aligned}
    \,\left|\,
      \vphantom{
        \begin{aligned}
          & \\
          & \\
          &
        \end{aligned}
        }
    \begin{aligned}
      & \srs \gets \kgen(\secparam, \maxdeg),\\
      & (c, \aux) \gets \adv_1(\srs; r_1), z \sample \FF, \\
      &  (s, o) \gets \adv_2(\srs, \aux, c, z; r_2)
    \end{aligned}
  \right.\right]
  \geq 1 - \epsk(\secpar).
\]
In that case we say that $\PCOM$ is $\epsk$-knowledge.
\end{description}
Intuitively when a commitment scheme is a commitment of knowledge then if an
adversary produces a (valid) commitment $c$, which it can open, then it also
knows the underlying polynomial $\p{f}$ which commits to that value.

\section{New definitions and primitives}
\subsection{Polynomial commitment schemes}

\begin{definition}[Simulation extractable polynomial commitment]
  \label{def:sepcom}
  Let $\PCOM = (\kgen, \com, \open, \verify)$ be a polynomial commitment
  scheme with a simulator $\mathsf{SimSample}, \mathsf{SimOpen}$. Let $\maxdeg$ be a maximal degree of polynomials that can be
  committed.
  Let $\oracles$ be an oracle which on input
  \begin{description}
%   \item [$(\msg{commit}, f)$:] returns commitment $c = \com(f)$ and adds $(f,
% c)$ to list $Q$.
\item[$(\msg{commit})$:] Run $c \gets \mathsf{SimSample}(\secparam)$ and add $c$ to $\Qcom$.
  \item[$(\msg{open}, c, x, y)$:] if $c \in \Qcom$ and $x\notin \Qev$, add $x$ to $\Qev$ and return $\mathsf{SimOpen(\td, c,x,y)}$.
  \end{description}
  We say that $\PCOM$ is \emph{simulation extractable} if for any $\ppt$
  adversary $\adv$ with oracle access to $\oracles$ there exists extractor
  $\ext$ such that
\[
  \Pr \left[
    \begin{aligned}
      & \p{f} = \ext_\adv(\srs, c; r),\\
      & c = \com(\srs, \p{f}),\\
      & \verify(\srs, c, z, s, o) = 1,\\
      & z \not\in \Qev
    \end{aligned}
    \,\left|\,
      \vphantom{
        \begin{aligned}
          & \\
          & \\
          & \\
          &
        \end{aligned}
        }
    \begin{aligned}
      & \srs,\td \gets \kgen(\secparam, \maxdeg),\\
      & (c, z, s, o) \gets \adv^{\oracles}(\srs; r), \\
      % & z \sample \FF,\\
      % & (s, o) \gets \adv^{\oracles}(\srs, z; r)
    \end{aligned}
  \right.\right]
  \geq 1 - \epsk(\secpar).
\]
\end{definition}



\begin{definition}[Simulation extractable polynomial commitment]
  \label{def:sepcom}
  Let $\PCOM = (\kgen, \com, \open, \verify)$ be a polynomial commitment
  scheme. Let $\maxdeg$ be a maximal degree of polynomials that can be
  committed, $H$ be a set of $\maxdeg + 1$ elements in $\FF$ and
  $\van{H}$ is a vanishing polynomial for $H$.
  
  Let $\oracles$ be an oracle which on input
  \begin{description}
%   \item [$(\msg{commit}, f)$:] returns commitment $c = \com(f)$ and adds $(f,
% c)$ to list $Q$.
\item[$(\msg{commit}, f, d)$:] for $\deg(f) = d'$, $d' \leq d \leq \maxdeg$,
  picks $d - d'$ random elements $r_1, \ldots, r_{d - d'}$, sets 
  polynomial $g(X) = f(X) + \van{H}(r_1 X^{d' + 1} + \ldots + r_{d - d'} X^{d})$, returns
  commitment $c = \com(g)$ and adds $(g, c)$ to list $\Qcom$.
  \item[$(\msg{evaluate}, c, z)$:] returns $f(z)$ where $f$ is a polynomial
    which commitment is $c$ and $(f, c) \in \Qcom$; add $z$ to $\Qev$.
  \item[$(\msg{open}, c, x, y)$:] returns an opening $o$ for commitment $c$
    assuring that for some polynomial $f$, such that $c \in \image(\com(f))$,
    holds $f(x) = y$.
  \end{description}
  We say that $\PCOM$ is \emph{simulation extractable} if for any $\ppt$
  adversary $\adv$ with oracle access to $\oracles$ there exists extractor
  $\ext$ such that
\[
  \Pr \left[
    \begin{aligned}
      & \p{f} = \ext_\adv(\srs, c; r),\\
      & c = \com(\srs, \p{f}),\\
      & \verify(\srs, c, z, s, o) = 1,\\
      & z \not\in \Qev
    \end{aligned}
    \,\left|\,
      \vphantom{
        \begin{aligned}
          & \\
          & \\
          & \\
          &
        \end{aligned}
        }
    \begin{aligned}
      & \srs \gets \kgen(\secparam, \maxdeg),\\
      & (c, z, s, o) \gets \adv^{\oracles}(\srs; r), \\
      % & z \sample \FF,\\
      % & (s, o) \gets \adv^{\oracles}(\srs, z; r)
    \end{aligned}
  \right.\right]
  \geq 1 - \epsk(\secpar).
\]
%\michals{21.06}{Write it as a game.}
  \michals{23.04}{Can $\ext$ ask $\adv$ to give evaluations of the committed
    polynomial? That is how $\ext$ in a proof system works -- it evaluates
    polynomials submitted by the adversary on multiple challenges.}
\end{definition}

\begin{definition}[Rational SE PCOM]
   \label{def:rational_sepcom}
   We call a simulation extractable polynomial commitment $\PCOM$
   \emph{rational} if $\oracles$ on input $(\msg{commit}, f, d)$ accepts $f$
   being a rational function (not only a polynomial).
 \end{definition}

 \begin{definition}[$f$-SE PCOM]
   \label{def:f_sepcom}
   We call a simulation extractable polynomial commitment $\PCOM$ $f$-simulation
   extractable if $\oracles$ accepts input
   $(\msg{operate}, f, c_1, \ldots, c_k)$. On that input, $\oracles$ retrieves
   polynomials $f_1, \ldots, f_k$ which are committed in $c_1, \ldots, c_k$, 
   returns $c = \com(f(f_1, \ldots, f_k))$, and adds $(f(f_1, \ldots, f_k), c)$
   to $\Qcom$.
 \end{definition}

 \begin{definition}[One-to-many openable\hl{Good name needed}]
   We call a commitment scheme $\PCOM$ one-to-many openable \hl{good name
     needed} if for any $\adv$ who outputs commitments $c_1, \ldots, c_k$,
   evaluation point $z$, evaluations $s_1, \ldots, s_k$ and batch opening $o$,
   which certifies that polynomials $f_i$ evaluates at $z$ to $s_i$ and
   $c_i \in \image(\com(f_i))$, there exists $\ppt$ algorithm $\bdv$ that
   produces valid openings $o_i$ for each triple $(c_i, z, s_i)$.
 \end{definition}
 Intuitively, we say that a polynomial commitment is one-to-many openable if we
 can deduce that adversary who successfully batch opens a number of polynomial
 commitments could also successfully open each of the commitments separately.

 \michals{23.06}{That's easy for KZG batched as in Plonk (with minor difference)
   -- just get a number of batch openings and do Gaussian elimination.}

 \begin{definition}[Polynomial proof system]
\hl{The proof system and the polynomial commitment scheme use virtually the same
SRS. (Both SRS could differ in some efficiency related elements, but computation
    of these don't require any secret knowledge)}
   \end{definition}

\subsection{Polynomial IOP}
 \begin{definition}[$\eps$-sufficiently simulatable PCOM]
   Let $\PCOM$ be a SE polynomial commitment scheme and
   $\PS = (\kgen, \prover, \verifier, \simulator)$ a polynomial zero-knowledge proof system
   for relation $\REL$. We call $\PCOM$ \emph{$\eps$-sufficiently simulatable for
     $\PS$} if there exist a $\ppt$ algorithm $\adv$ such that for
   $\srs \sample \kgen$, all $(\inp, \wit) \in \REL$ holds
   \[
     \SD_{\srs \sample \kgen(\secparam)}(\prover(\srs, \inp, \wit),
     \adv^{\oracles}(\srs, \inp)) \leq \eps(\secpar).
   \]
 \end{definition}
 Intuitively, we call $\PCOM$ sufficiently simulatable for $\PS$ if a $\ppt$
 $\adv$ given access to $\PCOM$'s simulator oracle $\oraclespcom$ can produce a
 simulated proof for $\PS$.

 \begin{definition}[Polynomial IOP,~\cite{EPRINT:Szepieniec20}]
  \label{def:piop}
  Let $\REL$ be an indexed relation with a corresponding language $\LANG$, $\FF$
  some finite field, $\maxdeg$ a degree bound, $\vereq_{\cdot}(X) \in \FF[X]$ a
  verification equation, and $\eps, \noofp$ parameters.
  A \emph{polynomial
    IOP for $\REL$ with degree bound $\maxdeg$} is a pair of interactive
  machines $\prover, \verifier$ such that
\begin{itemize}
\item $(\prover, \verifier)$ is an interactive proof for $\LANG$ with $r$ rounds
  and soundness error $\epss$;
\item $\prover$ sends to $\verifier$ polynomials $f_i \in \FF[X]$,
  $i \in \range{1}{\noofp}$, of degree at most $\maxdeg$;
\item $\verifier$ is an oracle machine with access to a list of oracles, which
  contains one oracle for each polynomial it has received from the prover;
\item When an oracle associated with a polynomial $f_i(X)$ is queried on a point
  $z_j \in \FF$, the oracle responds with the value $f_i(z_j)$; 
\item Oracle for $f_i$ can be queried at at most $\noofq$ points; 
\item $\verifier$ sends challenges $\alpha_k \in \FF$ to $\prover$;
\item $\verifier$ is public coin.
\item $\verifier$ accepts the transcript $\zkproof$ if
  \(
    \condprob{\vereq_{\zkproof}(X) \neq 0}{\zkproof \gets \langle\prover(\inp,
        \wit), \verifier(\inp)\rangle} \leq \eps(\secpar),
  \)
  for some predefined negligible $\eps$ and verification equation $\vereq_{\cdot}(X)$
  parametrized by $\zkproof$.
 \michals{28.06}{Introduce idealised check here?}
\end{itemize}
\end{definition}

\michals{28.06}{Adjust for verification equations}
\michals{28.04}{Add preprocessing and zero knowledge}

\begin{definition}[Witness encoding PIOP (WEPIOP)]
  \label{def:wepiop}
  Let $\PS$ be a PIOP.  We say that $\PS$ is \emph{witness encoding} if there is
  a function $\decode$ and set $\encset \in [\noofp]$ such that for any
  $(\inp, \wit) \in \REL$ and polynomials $\smallset{f_i}_{i \in [\noofp]}$ sent by an
  honest prover, $\decode(\smallset{f_i}_{i \in \encset}) = \wit$. We call $\encset$ the
  \emph{encoding set}.
\end{definition}
In other words, PIOP is witness encoding if for any valid proof for a statement
$\inp$ in the language, the corresponding witness can be read from the
polynomial coefficients. We note that this is the case for virtually all
PIOPs. \michals{28.04}{Check!}

\begin{definition}[Somehow deterministic WEPIOP]
  \label{def:sdwepiop}
  Let $\PS$ be a WEPIOP for $\REL$. For each polynomial $f_i$ sent by the prover
  denote by $A_i$ the set of challenges sent by the verifier and by $F_i$ the
  set of polynomials sent by the prover \emph{before} the prover sends
  $f_i$. Let $\encset$ be an encoding set. We say that $\PS$ is \emph{somehow
    deterministic} (SD) if for any $(\inp, \wit) \in \REL$, polynomials
  $\smallset{f_i}_{i \in [\noofp]}$ send by the prover, and encoding set
  $\encset \neq [\noofp]$ each polynomial
  $f_j \in \smallset{f_i}_{i \in [\noofp] \setminus \encset}$ is determined by
  \begin{itemize}
    \item polynomials $F_j$, and
    \item the verifier's challenges $A_i$, and
    \item the witness $\wit$.
  \end{itemize}
\end{definition}
Intuitively, we say that WEPIOP is somehow deterministic if the only
non-deterministic messages send by the prover are polynomials encoding the
witness, and all other messages are determined by the previous one, witness, and
verifier's challenges.

\section{From polynomial IOP to a usable proof system}
\begin{figure}
  \centering
    \begin{description}
    \item[Input]
      \begin{itemize}
      \item ZK PIOP $\PIOP = (\prover, \verifier, \simulator)$
      \item PCOM $\PCOM = (\kgen, \com, \open, \verify)$
      \end{itemize}
    \item[Compiler]
      \begin{itemize}
        \item $\PS.\prover$ acts as $\PIOP.\prover$, except
          \begin{itemize}
          \item when $\PIOP.\prover$ sets up a polynomial oracle $\oracleo_f$,
            $\PS.\prover$ sends commitment $c = \com(f)$;
          \item when $\PS.\verifier$ asks $\PS.\prover$ to open a commitment
            $c = \com(f)$ at $z$ it returns $f(z)$ and a proof $o$ of
            correctness of the opening.
          \end{itemize}
        \item $\PS.\verifier$ acts as $\PIOP.\verifier$, except when
          $\PIOP.\verifier$ asks oracle $\oracleo_f$ for an evaluation of $f$ at
          $z$, $\PS.\verifier$ sends $z$ to $\PS.\prover$ and expects $f(z)$
          in return.
        \item $\PS.\simulator$  acts as $\PIOP.\simulator$, except
          \begin{itemize}
          \item when $\PIOP.\simulator$ sets up a polynomial oracle $\oracleo_f$,
            $\PS.\simulator$ sends commitment $c = \com(f)$;
          \item when $\PS.\verifier$ asks $\PS.\simulator$ to open a commitment
            $c = \com(f)$ at $z$ it returns $f(z)$ and a proof $o$ of
            correctness of the opening.
          \end{itemize}
        \end{itemize}
    \end{description}  
  \label{fig:piop_to_ps}
  \caption{From PIOP to PS}
\end{figure}

\subsection{From PIOP to zkPIOP}
\michals{24.06}{Need to show how to get a ZK PIOP from PIOP}

\begin{theorem}[From WEPIOP to ZK WEPIOP]
  Let $\PIOP = (\prover, \verifier)$ be a WEPIOP and $E$ its encoding set,
  $\maxdeg$ be a maximal degree of polynomials sent by the prover; and
  let $\PIOP' = (\prover', \verifier')$ be a WEPIOP such that
  \begin{itemize}
  \item Both parties get as input a set of $\FF$ elements $H$, such that
    $\abs{H} = \maxdeg + 1$. Denote the vanishing polynomial for $H$ by $\van{H}$.
  \item $\prover'$ acts as $\prover$ except for $f_i(X) \in E$. Let $k_i$ be a
    number of queries $\verifier$ makes to the oracle $\oracleo_{f_i}$ and
    $d_i = \deg(f_i)$, then $\prover'$ computes
      \[
        g_i(X) = f_i(X) + \van{H}\left(X^{d_i + 1} b_1 + \ldots
        X^{d_i + k_i + 1} b_{k_i + 1}\right)
      \]
      for random $b_1, \ldots, b_{k + 1}$ and sets oracle $\oracleo_{g_i}$.
    \item $\verifier'$ acts as $\verifier$. \michals{28.06}{We don't want to
        change the verifier and its equations -- that's why we have $\van{H}$.}
  \end{itemize}
\end{theorem}
\begin{proof}
  \ncase{Completeness} 

  \ncase{Soundness} 

  \ncase{Zero-knowledge} To show the property we construct a simulator
  $\simulator$ and argue that it produces proofs indistinguishable from proofs
  of a real prover. The simulator behaves as real prover, except for
  witness-encoding polynomials in $\smallset{f_i}_{i \in E}$. For
  $f_j \in \smallset{f_i}_{i \in E}$, where it
  \begin{itemize}
  \item Picks randomizers $b_1, \ldots, b_{\noofq_j}$ and computes polynomial
    $g_i(X) =  \van{H}(b_1 X + \ldots b_{\noofq_j} X^{\noofq_j})$. 
  \item \michals{28.06}{The simulator can open the commitment to any value, but
      he need to know *which* value}
  \end{itemize}
  
\end{proof}

\comment{
\subsection{Security of compilation}
\michals{28.06}{This section is more for learning than a real result}
\begin{theorem}
  Let $\PS = (\PS.\prover, \PS.\verifier, \PS.\simulator)$ be a ZK PIOP with knowledge soundness error
  $\epsks$ where the prover sends up to $\noofp$ polynomials. Let $\PCOM$ be a
  knowledge polynomial commitment scheme with extraction error $\epsext$. Let
  $\PSc = (\PS.\prover, \PS.\verifier, \PS.\simulator)$ be a proof system such that
  \begin{description}
  \item[$\PS.\prover$] acts as $\PIOP.\prover$, except
    \begin{itemize}
    \item when $\PIOP.\prover$ sets up a polynomial oracle $\oracleo_f$,
      $\PS.\prover$ sends commitment $c = \com(f)$;
    \item when $\PS.\verifier$ asks $\PS.\prover$ to open a commitment
      $c = \com(f)$ at $z$ it returns $f(z)$ and a proof $o$ of correctness of
      the opening.
  \end{itemize}
  \item[$\PS.\verifier$] acts as $\PIOP.\verifier$, except when $\PIOP.\verifier$
    asks oracle $\oracleo_f$ for an evaluation of $f$ at $z$, $\PS.\verifier$
    sends $z$ to $\PS.\prover$ and expects $f(z)$ in return.
  \item[$\PS.\simulator$]  acts as $\PIOP.\simulator$, except
    \begin{itemize}
    \item when $\PIOP.\simulator$ sets up a polynomial oracle $\oracleo_f$,
      $\PS.\simulator$ sends commitment $c = \com(f)$;
    \item when $\PS.\verifier$ asks $\PS.\simulator$ to open a commitment
      $c = \com(f)$ at $z$ it returns $f(z)$ and a proof $o$ of correctness of
      the opening.
  \end{itemize}
  \end{description}
  Then $\PSc$ is knowledge sound with knowledge error at most $\epsks + \noofp \cdot \epsext$.
\end{theorem}
\begin{proof}
  Let $\adv$ be an adversary that breaks knowledge soundness of $\PSc$ with
  probability $\eps$ greater than $\epsks + \noofp \cdot \epsext$.  We build
  $\bdv$ that breaks knowledge soundness of $\PS$ with probability greater than
  $\epsks$. More precisely, let $\ext_\adv$ be an extractor for $\adv$ and
  $\ext_\bdv$ be an extractor for $\bdv$. We show that if $\adv$ produces an
  instance and proof such that $\ext_\adv$ fails to extract the corresponding
  witness, then $\bdv$ produces an instance and proof that $\ext_\bdv$ fails as well.

  $\bdv$ starts by picking an SRS $\srs$ for the polynomial commitment scheme
  $\PCOM$ and provides $\srs$ to $\adv$. Let $\ext^{\PCOM}_\adv$ be a polynomial
  commitment extractor for $\adv$ that for any commitment $c$ produced by $\adv$
  outputs polynomial $f$ such that $c \in \image(\com(f))$, except with
  probability $\epsext$.  Let $\inp$ be the instance $\adv$ creates a proof
  for. Each time $\adv$ sends a commitment $c$, $\bdv$ uses $\ext^{\PCOM}_\adv$
  to extract polynomial $f$ from $c$ and sends $f$ to a newly set oracle
  $\oracleo_f$.  \michals{5.5}{how much we can generalize here?  I.e.~could we
    have a single proof that would cover algebraic adversaries that returns with
    $c$ also a vector of group elements' logarithms; or commitment schemes where
    there is an extraction key $k$ allowing to extract $f$ from $c$?}  Each time
  $\PS.\verifier$ sends a challenge $\alpha$, $\bdv$ passes $\alpha$ to $\adv$
  as $\PSc.\verifier$'s challenge. Note that $\PS.\verifier$ expects an oracle
  for some (challenge-dependent) polynomial $f$ as an answer, thus $\adv$
  replies with a commitment to some polynomial $f'$. $\bdv$ extracts $f'$ and
  sets a new oracle for it.  When $\PS.\verifier$ queries some oracle
  $\oracleo_f$ at $z$ to learn $f(z)$, $\bdv$ replies with $f(z)$, sends $z$
  to $\adv$ and gets $y$. If $\adv$ provides $y \neq f(z)$, then $\bdv$ aborts
  the proof. Importantly, that may happen with probability $\epsev$ only as an
  acceptable proof from $\adv$ would require breaking evaluation binding
  property of $\PCOM$. 
  
  Eventually, $\adv$ finalizes its proof for $\inp$. Note that
  if $\PSc.\verifier$ accepts the proof provided by $\adv$, then $\PS.\verifier$
  accepts the proof provided by $\bdv$.

  Probability that $\bdv$ \emph{fails} is upper-bounded by three events. One is
  that $\adv$ fails to provide a convincing proof such that $\ext_\adv$ does not
  output a corresponding witness. Probability of this event is upper-bounded by
  $(1 - \eps)$. Another is that $\adv$ breaks evaluation binding property of the
  commitment scheme, since $\verifier$ makes up to $\noofev$ evaluations, that
  happens with probability at most $\noofev \cdot \epsev$ Furthermore, $\bdv$
  may fail to extract some of the polynomials which $\adv$ made commitments
  for. Since $\adv$ commits to $\noofp$ polynomials and $\bdv$ fails to extract
  each of them with probability at most $\epsext$, by the union bound $\bdv$
  fails to extract \emph{some} of the polynomials with probability upper-bounded
  by $\noofp \cdot \epsext$.

  Note that if $\adv$ manages to output an instance $\inp$ and proof $\zkproof$
  that extractor $\ext_\adv$ fails to produce a corresponding witness $\wit$,
  then $\ext_\bdv$ also fails to produce a witness for the instance output by
  $\bdv$. This comes from the simple observation, if $\ext_\bdv$ was successful,
  then $\ext_\adv$ could run $\bdv$ internally along with $\adv$ until the former
  outputs instance $\inp$ and proof $\zkproof'$, then use $\ext_\bdv$ to extract
  witness $\wit$ for $\inp$. Importantly, both $\adv$ and $\bdv$ output the same instance.

  Hence the probability of $\bdv$'s failure in generating a proof for instance
  $\inp$ that $\ext_\bdv$ fails to extract a correct witness is upper-bounded by
  \[
    (1 - \eps) + \noofp \cdot \epsext.
  \]
  Hence, for $\eps > \epsks + \noofp \cdot \epsext$ adversary $\bdv$ wins with probability at least
  \[
    \epsks + \noofp \cdot \epsext - \noofp \cdot \epsext  = \epsks.
  \]
  \qed
\end{proof}
}

\subsection{Simulation extractable NIZKs from simulation extractable polynomial
  commitments}

\begin{theorem}
  Let $\PIOP = (\PIOP.\prover, \PIOP.\verifier, \PIOP.\simulator)$ be a ZK PIOP
  for $\REL$ with knowledge soundness error $\epsks$ where the prover sends up
  to $\noofp$ polynomials. Let $\PCOM$ be $\eps(\secpar)$-sufficiently
  simulatable polynomial commitment scheme for $\PS$ with extraction error
  $\epsext$. Let $\PS = (\PS.\prover, \PS.\verifier, \PS.\simulator)$ be a proof system such
  that
  \begin{enumerate}
  \item $\PS.\prover$ acts as $\PIOP.\prover$, except
    \begin{itemize}
    \item when $\PIOP.\prover$ sets up a polynomial oracle $\oracleo_f$,
      $\PS.\prover$ sends commitment $c = \com(f)$;
    \item when $\PS.\verifier$ asks $\PS.\prover$ to open a commitment
      $c = \com(f)$ at $z$ it returns $f(z)$ and a proof $o$ of correctness of
      the opening.
  \end{itemize}
  \item $\PS.\verifier$ acts as $\PIOP.\verifier$, except when $\PIOP.\verifier$
    asks oracle $\oracleo_f$ for an evaluation of $f$ at $z$, $\PS.\verifier$
    sends $z$ to $\PS.\prover$ and expects $f(z)$ in return.
  \item $\PS.\simulator$ acts as $\PIOP.\simulator$, except
     \begin{itemize}
    \item when $\PIOP.\simulator$ sets up a polynomial oracle $\oracleo_f$,
      $\PS.\simulator$ sends commitment $c = \com(f)$;
    \item when $\PS.\verifier$ asks $\PS.\simulator$ to open a commitment
      $c = \com(f)$ at $z$ it returns $f(z)$ and a proof $o$ of correctness of
      the opening.
  \end{itemize}
  \end{enumerate}
  Then $\PS$ is simulation extractable with extraction error at most \hl{...}.
\end{theorem}
\begin{proof}
  From the simulation extractability of $\PCOM$ we will derive simulation
  extractability of $\PS$ by constructing a $\PS$ extractor $\ext^{\PS}$ using
  $\PCOM$ extractor $\ext^{\PCOM}$.

  Let $\adv(\srs)$ be a $\PS$ adversary with oracle access to a $\PS$ simulator
  $\simulator$. We show construction of an extractor $\ext^{\PS}$ which from
  acceptable proof $\zkproof$ for instance $\inp$ output by $\adv$ produces
  witness $\wit$ such that $\REL(\inp, \wit) = 1$. We proceed by game hoping.
  
  \ngame{1} Let $\ext^{\PS}_\adv$ be an extractor for adversary $\adv$. In this
  game the adversary is given oracle $\oraclesps$ and produces an instance
  $\inp$ and proof $\zkproof$. $\adv$ wins if $\ext_\adv$ does not output the
  corresponding witness $\wit$.

  \ngame{2} In this game $\adv$'s access to $\oraclesps$ is substituted by
  access to $\bdv^\oraclespcom$ which simulates $\oraclesps$.
  Since $\PCOM$ is sufficiently simulatable for $\PS$, probability that $\adv$
  wins in Game $\game{1}$ but not in $\game{2}$ (or vice-versa) is at most
  $\eps(\secpar)$.

  \medskip\noindent
  We now analyze the probability that $\adv$ wins in Game $\game{2}$. Since
  $\PCOM$ is simulation extractable, there exists an extractor $\ext_\bdv$ which 
  extracts, for $i \in \range{1}{\noofp}$, polynomials $f_i$ if $\bdv$ output
  \begin{inparaenum}[(1)]
  \item commitment $c_i$ and $c_i \in \image(\com(f_i))$;
  \item evaluations $s_i$ for evaluation points $z_i$ provided by the $\PS.\verifier$;
  \item openings $o_i$;
  \end{inparaenum}
  \michals{28.06}{Stopped here -- we need more details of PIOP to argue about
    $\bdv$ returning a valid opening of commitment. Further we want to state
    that if the proof was accepted then the commitments have been opened
    successfully. If the proof system allow for batch opening, then still we can
  open every single commitment.}
  
\end{proof}
\newcommand{\Kzg}{\mathsf{KZG}}
\newcommand{\kzg}{\mathsf{kzg}}

\def\cgen{{\sf ComGen}}
\def\commit{{\sf Com}}
%\def\comopen{{\sf ComOpen}}
%\def\openver{{\sf OpenVer}}
% \newcommand{\comkg}{\mathsf{KG}}
\newcommand{\PC}{\mathsf{PC}}
\newcommand{\CM}{\commit}

\def\open{{\sf Open}}
\def\check{{\sf Check}}
%\def\witness{{\sf wit}}
\def\gk{{\sf gk}}

\def\ck{{\sf ck}}
\newcommand{\secp}{\lambda}

\section{KZG commitments are simulation extractable}
$\Kzg.\PC = (\Kzg.\cgen,\Kzg.\CM,\allowbreak  \Kzg.\open,\allowbreak \Kzg.\check)$ is defined over bilinear groups $\gk=(p,\GG_1,\allowbreak \GG_2, \allowbreak \GG_T )$ with $\GG_1 =\langle g\rangle, \GG_2 =\langle h \rangle$ as follows:
\begin{description}%[topsep=5pt]
\item[$\Kzg.\cgen(1^\secpar, n) \to (\ck_\kzg, \vk_\kzg)$:] Set keys
$\ck_\kzg = \{g^{\alpha^i}\}_{i=0}^{n-1}, \allowbreak\vk_\kzg = h^\alpha$.
\item[$\Kzg.\CM(\ck_\kzg; f(X)) \to C_f$:]  For $f(X) = \sum_{i=0}^{n-1} f_i X^i$, computes  $C_f=\prod _{i=0}^{n-1} g^{f_i \alpha^i} = g^{f(\alpha)} $.
\item[$\Kzg.\open(\ck_\kzg; C_f, x, y; f(X)) \to \pi$:] For an evaluation point $x$, a value $y$, compute the quotient  polynomial $q(X) = \displaystyle\frac{f(X) -y }{X-x}$ and output a proof $\pi = C_q = \Kzg.\CM(\ck_\kzg; q(X)) $.
\item[$\Kzg.\check(\vk_\kzg = h^\alpha, C_f, x, y, \pi) \to 1/0$:] Check if $e(C_f \cdot  g^{-y}, h)=e(C_q , h^{\alpha}\cdot h^{-x})$.
\end{description}

We move toward considering a symbolic verification equation $V'$ for which we have:
$V(C_{f},x,y,\pi) =  e(C_f \cdot  g^{-y}, h) - e(C_q , h^{\alpha}\cdot h^{-x}) = 0$ iff $V'(K * Transcript (T)) = 0$.

The trapdoors variables $T$ consist of the trapdoor variable $X$ of the setup and the randomness variables $A_{i}$ of simulated proofs:
$T=(X, \{A_{i}\})$

The transcript consists of the setup $\{[X^{i}]_{1}\}, [X]_{2}$ and simulated proofs $\{[A_{i} + y_{i}]_{1}, [\frac{A_{i}}{X-x_{i}}]\}$.

The honest verification equation is
$[f(X) - y]_1 \circ [h]_{2} - [q(X)]_1 \circ [X-x]_{2}=0$
while an adversary can provide rational functions
$f(X, \{A_{i}\}) = \sum C_{1i} X^{i} + \sum C_{2i} A_{i} + \sum C_{3i} \frac{A_{i}}{X-x_{i}}$ and
$q(X, \{A_{i}\}) = \sum Q_{1i} X^{i} + \sum Q_{2i} A_{i} + \sum Q_{3i} \frac{A_{i}}{X-x_{i}}$ computed as linear combinations of elements in the transcript. Note that we performed a simplification here as the $y_{i}$ are picked and known by the adversary.

The security game gives us that $x \neq x_{i}$.

We inline to get the following equation which we then analyze in detail,
\begin{align*}
  \left[\sum C_{1i} X^{i} + \sum C_{2i} A_{i} + \sum C_{3i} \frac{A_{i}}{X-x_{i}} - y\right]_{1} \circ [1]_{2} - \left[\sum Q_{1i} X^{i} + \sum Q_{2i} A_{i} + \sum Q_{3i} \frac{A_{i}}{X-x_{i}}\right]_{1} \circ [X-x]_{2} = 0
  \end{align*}

We now look at diferent monomials in $T$ of this equation to derive constraints on $C_{ji}$ and $Q_{ji}$ imposed by the verification equation:
\begin{itemize}
  \item[$A_{i}$:] $C_{2i} A_{i} = - Q_{2i}A_{i} x$. As $Q_{2i}=0$, it follows
        that $C_{{2i}}=0$. This step relies on $x \neq x_{i}$ and thus
        $\frac{A_{i} (X-x)}{X-x_{i}}$ cannot cancel out its denominator.
  \item[$A_{i}X$:] $Q_{2i} A_{i} X = 0$
  \item[$\frac{A_{i}X}{X-x_{i}}$:] $Q_{3i} \frac{A_{i} X}{X-x_{i}} = 0$.
  \item[$\frac{A_{i}}{X-x_{i}}$:]
        $C_{3i} \frac{A_{i}}{X-x_{i}} = Q_{{3i}} \frac{A_{i}}{X-x_{i}} $. As $Q_{3i}=0$, it follows
        that $C_{{3i}}=0$.
      \end{itemize}

      We are thus back to the honest verification equation.

\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev1,cryptobib/crypto}

\end{document}
