% !TeX spellcheck = en_UK
% \let\accentvec\vec              
\documentclass[runningheads,11pt]{llncs}
%\let\spvec\vec \let\vec\accentvec
\newcommand\hmmax{0}
\newcommand\bmmax{0}

\usepackage{amssymb,amsmath}
%\let\vec\spvec
%\usepackage{lmodern}
\usepackage{newtxmath,newtxtext}
\usepackage[T1]{fontenc}
% \def\vec#1{\mathchoice{\mbox{\mathbf$\displaystyle#1$}}
% {\mbox{\mathbf$\textstyle#1$}} {\mbox{\mathbf$\scriptstyle#1$}}
% {\mbox{\mathbf$\scriptscriptstyle#1$}}}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{<-> mathx10}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathAccent{\widebar}{0}{mathx}{"73}

\usepackage{soulutf8} \soulregister\cite7 \soulregister\ref7
\soulregister\pageref7 \usepackage{hyperref}
\usepackage[color=yellow]{todonotes} \hypersetup{final} \usepackage{mathrsfs}
\usepackage[advantage,asymptotics,adversary,sets,keys,ff,lambda,primitives,events,operators,probability,logic,mm,complexity]{cryptocode}

\usepackage{cite} 
\usepackage{booktabs}
\usepackage{paralist}
\usepackage[innerleftmargin=5pt,innerrightmargin=5pt]{mdframed}
\usepackage{caption}
\captionsetup{belowskip=0pt}
\usepackage{bm}
\usepackage{url}
%\usepackage{dirtytalk}
\newcommand{\say}[1]{\emph{``#1''}}
\usepackage[margin=0.7in,a4paper]{geometry}
\usepackage[normalem]{ulem}
\usepackage{dashbox}
\newcommand{\dboxed[1]}{\dbox{\ensuremath{#1}}}
\usepackage{hyperref}
\usepackage[capitalise]{cleveref}
\usepackage{braket} %for the \braket{} command

%\usepackage{mathptmx}


\include{macros}
\include{macros_antonio}

\title{On PHP-based zkSNARKs}

\author{} 
%\iflncs{
\institute{} 

\allowdisplaybreaks

\begin{document} \sloppy \maketitle

\begin{abstract}
  In this paper we investigate properties of zkSNARKs obtained by
  compiling a PHP proof using a polynomial commitment scheme. The question we
  try to answer is \say{What polynomial commitment's properties propagate to
    the resulting zkSNARK?}. The properties we focus on are:
  \begin{compactenum}
  \item simulation extractability,
  \item SRS updatability,
  \item SRS-updatable simulation extractability,
  \item subversion zero knowledge.
  \end{compactenum}
  The research hypothesis is \say{A NIZK obtained from a simulation extractable /
    SRS-updatable / SRS updatable SE / subversion zero knowledge polynomial
    commitment is simulation extractable /
    SRS-updatable / SRS updatable SE / subversion zero knowledge.} To be able to
  show the hypothesis we need to solve a number of problems
  \begin{compactenum}
  \item Neither simulation extractability, SRS-updatability, SRS-updatable
    simulation extractability, nor subversion zero knowledge have been defined
    for a polynomial commitment scheme. Another contribution of the paper is
    defining these properties. 
  \item Similarly, there is no definition for SRS-updatable simulation
    extractable NIZKs.
  \item The polynomial IOP is defined very generally, cf.~\cref{def:piop}, what
    makes showing generic properties difficult. The paper would propose tighter
    definitions which would emphasize more the structure of PHP,
    but would not narrow a class of possible (from the practical point of view)
    PHP too much, cf.~\cref{def:wepiop,def:sdwepiop}.
  \end{compactenum}
  
\end{abstract}

\section{Preliminaries}
\paragraph{Polynomial commitment scheme.}
\label{sec:poly_com}
In the polynomial commitment scheme $\PCOM = (\kgen, \com, \open, \verify)$ the
prover $\prover$ convinces the verifier $\verifier$ that some polynomial $\p{f}$
which $\prover$ committed to evaluates to $s$ at some point $z$ chosen by
$\verifier$.  The key generation algorithm $\kgen$ takes as input a security
parameter $\secparam$ and a parameter $\maxdeg$ which determines the maximal
degree of the committed polynomial. We assume that $\maxdeg$ can be read from
the output SRS.
  
We emphasize the following properties of a secure polynomial commitment
$\PCOM$:
\begin{description}
\item[Evaluation binding:] A $\ppt$ adversary $\adv$ which outputs a commitment
  $\vec{c}$ and evaluation points $\vec{z}$ has at most negligible chances to
  open the commitment to two different evaluations $\vec{s}, \vec{s'}$. That is,
  let $k \in \NN$ be the number of committed polynomials, $l \in \NN$ number of
  evaluation points, $\vec{c} \in \GRP^k$ be the commitments,
  $\vec{z} \in \FF_p^l$ be the arguments the polynomials are evaluated at,
  $\vec{s},\vec{s}' \in \FF_p^k$ the evaluations, and
  $\vec{o},\vec{o}' \in \FF_p^l$ be the commitment openings. Then for every
  $\ppt$ adversary $\adv$
	\[
		\Pr
			\left[
			\begin{aligned}
				& \verify(\srs, \vec{c}, \vec{z}, \vec{s}, \vec{o}) = 1,  \\ 
				& \verify(\srs, \vec{c}, \vec{z}, \vec{s}', \vec{o}') = 1, \\
				& \vec{s} \neq \vec{s}'
			\end{aligned}
			\,\left|\,\vphantom{\begin{aligned}
                  & \\
                  & \\
                  &
                \end{aligned}}
			\begin{aligned}
				& \srs \gets \kgen(\secparam, \maxdeg),\\
				& (\vec{c}, \vec{z}, \vec{s}, \vec{s}', \vec{o}, \vec{o}') \gets \adv(\srs)
			\end{aligned}
			\right.\right] \leq \negl\,.
	\]

\end{description}
	

\begin{description}
\item[Commitment of knowledge] For every $\ppt$ adversary
  $\adv = (\adv_1, \adv_2)$ who produces commitment $c$, gets random evaluation
  point $z$, and outputs evaluation $s$ with an opening $o$ there exists a
  $\ppt$ extractor $\ext$ such that
\[
  \Pr \left[
    \begin{aligned}
      & \neg \verify(\srs, c, z, s, o) = 1 \lor \\
      & (\p{f} = \ext_\adv(\srs, c, (r_1, r_2)),\\
      & c = \com(\srs, \p{f}) )\\
    \end{aligned}
    \,\left|\,
      \vphantom{
        \begin{aligned}
          & \\
          & \\
          &
        \end{aligned}
        }
    \begin{aligned}
      & \srs \gets \kgen(\secparam, \maxdeg),\\
      & (c, \aux) \gets \adv_1(\srs; r_1), z \sample \FF, \\
      &  (s, o) \gets \adv_2(\srs, \aux, c, z; r_2)
    \end{aligned}
  \right.\right]
  \geq 1 - \epsk(\secpar).
\]
In that case we say that $\PCOM$ is $\epsk$-knowledge.
\end{description}
Intuitively when a commitment scheme is a commitment of knowledge then if an
adversary produces a (valid) commitment $c$, which it can open, then it also
knows the underlying polynomial $\p{f}$ which commits to that value.

\markulf{23/08}{Wondering if the $\verify$ condition is really needed for extraction. In the AGM, if the adversary only sees the $\srs$ it has to output group element that is a linear combination of it.}

\section{New definitions and primitives}
\subsection{Polynomial commitment schemes}

\begin{definition}[Simulation extractable polynomial commitment]
  \label{def:sepcom}
  Let $\PCOM = (\kgen, \com, \open, \verify)$ be a polynomial commitment
  scheme with a simulator $\mathsf{SimSample}, \mathsf{SimOpen}$. Let $\maxdeg$ be a maximal degree of polynomials that can be
  committed.
  Let $\oracles$ be an oracle which on input
  \begin{description}
%   \item [$(\msg{commit}, f)$:] returns commitment $c = \com(f)$ and adds $(f,
% c)$ to list $Q$.
\item[$(\msg{commit})$:] Run $c \gets \mathsf{SimSample}(\secparam)$, add $c$ to $Q_{com}$, return $c$.
  \item[$(\msg{open}, c, x, y)$:] If $c\in Q_{{com}}$, run $o\gets \mathsf{SimOpen}(td,c,x,y)$, add $(c,x,y,o)$ to $Q_{op}$, and return $o$. Otherwise return $\bot$.
  \end{description}
  $Q_{sim}= (Q_{com},Q_{op})$. Let $\oraclec(c)$ be an oracle that returns $\bot$ if $Q_{chal}\neq \bot$. Otherwise sample $x$, set $Q_{chal}=(c,x)$, and return $x$.
  We say that $\PCOM$ is \emph{simulation extractable} if for any $\ppt$
  adversary $\adv$ with oracle access to $\oracles$ there exists extractor
  $\ext$ such that
\[
  \Pr \left[
    \begin{aligned}
      & (\p{f} = \ext_\adv(\srs, Q_{sim}, Q_{chal}; r),\\
      & \;c = \com(\srs, \p{f}))\\
      & \lor \verify(\srs, c, x, y, o) = 0
    \end{aligned}
    \,\left|\,
      \vphantom{
        \begin{aligned}
          & \\
          & \\
          & \\
          &
        \end{aligned}
        }
    \begin{aligned}
      & (\srs, td) \gets \kgen(\secparam, \maxdeg),\\
      & (y, o) \gets \adv^{\oracles,\oraclec}(\srs; r), \\
      % & z \sample \FF,\\
      % & (s, o) \gets \adv^{\oracles}(\srs, z; r)
    \end{aligned}
  \right.\right]
  \geq 1 - \epsk(\secpar).
\]
\end{definition}



\begin{definition}[Simulation extractable polynomial commitment]
  \label{def:sepcom}
  Let $\PCOM = (\kgen, \com, \open, \verify)$ be a polynomial commitment
  scheme. Let $\maxdeg$ be a maximal degree of polynomials that can be
  committed, $H$ be a set of $\maxdeg + 1$ elements in $\FF$ and
  $\van{H}$ is a vanishing polynomial for $H$.
  
  Let $\oracles$ be an oracle which on input
  \begin{description}
%   \item [$(\msg{commit}, f)$:] returns commitment $c = \com(f)$ and adds $(f,
% c)$ to list $Q$.
\item[$(\msg{commit}, f, d)$:] for $\deg(f) = d'$, $d' \leq d \leq \maxdeg$,
  picks $d - d'$ random elements $r_1, \ldots, r_{d - d'}$, sets 
  polynomial $g(X) = f(X) + \van{H}(r_1 X^{d' + 1} + \ldots + r_{d - d'} X^{d})$, returns
  commitment $c = \com(g)$ and adds $(g, c)$ to list $\Qcom$.
  \item[$(\msg{evaluate}, c, z)$:] returns $f(z)$ where $f$ is a polynomial
    which commitment is $c$ and $(f, c) \in \Qcom$; add $z$ to $\Qev$.
  \item[$(\msg{open}, c, x, y)$:] returns an opening $o$ for commitment $c$
    assuring that for some polynomial $f$, such that $c \in \image(\com(f))$,
    holds $f(x) = y$.
  \end{description}
  We say that $\PCOM$ is \emph{simulation extractable} if for any $\ppt$
  adversary $\adv = (\adv_1, \adv_2)$ with oracle access to $\oracles$ there
  exists extractor $\ext$ such that
\[
  \Pr \left[
    \begin{aligned}
      & \p{f} = \ext_\adv(\srs, Q_{\adv}, (r_1, z, r_2)),\\
      & c = \com(\srs, \p{f}),\\
      & \verify(\srs, c, z, s, o) = 1,
    \end{aligned}
    \,\left|\,
      \vphantom{
        \begin{aligned}
          & \\
          & \\
          & \\
          &
        \end{aligned}
        }
    \begin{aligned}
      & \srs \gets \kgen(\secparam, \maxdeg),\\
      & (c, \state) \gets \adv_1^{\oracles}(\srs; r_1), \\
      & z \sample \FF, \\
      & (s, o) \gets \adv_2^{\oracles}(\srs, c, z; \state, r_2)
    \end{aligned}
  \right.\right]
  \geq 1 - \epsk(\secpar).
\]
  \michals{23.04}{Can $\ext$ ask $\adv$ to give evaluations of the committed
    polynomial? That is how $\ext$ in a proof system works -- it evaluates
    polynomials submitted by the adversary on multiple challenges.}
\end{definition}

\markulf{17.08}{We can represent $\adv_{1}$ and $\adv_{2}$ using a single adversary $\adv_{\mathsf{chal}}$ with an additional oracle $\oraclec$ that on input $c$ returns $z$ on its single allowed call. The winning condition takes $c,z$ directly from that oracle call.}

\begin{definition}[$(k, \eps)$-aux-simulation extractable polynomial commitment]
  \label{def:sepcom}
  Let $\PCOM = (\kgen, \com, \open, \verify)$ be a polynomial commitment
  scheme. Let $\maxdeg$ be a maximal degree of polynomials that can be
  committed, $H$ be a set of $\maxdeg + 1$ elements in $\FF$ and
  $\van{H}$ is a vanishing polynomial for $H$.
  
  Let $\oracles$ be an oracle which on input
  \begin{description}
\item[$(\msg{commit}, f, d)$:] for $\deg(f) = d'$, $d' \leq d \leq \maxdeg$,
  picks $d - d'$ random elements $r_1, \ldots, r_{d - d'}$, sets 
  polynomial $g(X) = f(X) + \van{H}(r_1 X^{d' + 1} + \ldots + r_{d - d'} X^{d})$, returns
  commitment $c = \com(g)$ and adds $(g, c)$ to list $\Qcom$.
\item[$(\msg{commit}, rand, d)$:] picks a random polynomial $f$ of degree $d$ and
  outputs commitment $c = \com(f)$ and adds $(f, c)$ to the list $\Qcom$.
  \item[$(\msg{evaluate}, c, z)$:] returns $f(z)$ where $f$ is a polynomial
    which commitment is $c$ and $(f, c) \in \Qcom$; add $z$ to $\Qev$.
  \item[$(\msg{open}, c, z, y)$:] returns an opening $o$ for commitment $c$
    assuring that for some polynomial $f$, such that $c \in \image(\com(f))$,
    holds $f(z) = y$.
  \end{description}
  We say that $\PCOM$ is \emph{$(k, \eps)$-aux-simulation extractable} if for
  any $\ppt$ adversary $\adv$ with oracle access to
  $\oracles$ and random oracle $\ro$ there exists extractor $\ext$ such that
\[
  \Pr \left[
    \begin{aligned}
      & \p{f_1}, \ldots, \p{f_k} = \ext_\adv(\srs, Q_{\adv}, Q_{\ro}, r),\\
      & c_i = \com(\srs, \p{f_i}),\\
      & \verify(\srs, c_i, z_i, s_i o_i) = 1, \text{ for } i \in \range{1}{k}\\
      & z = \ro((c_1,\dots, c_{k}),\aux)
    \end{aligned}
    \,\left|\,
      \vphantom{
        \begin{aligned}
          & \\
          & \\
          & \\
          &
        \end{aligned}
        }
    \begin{aligned}
      & \srs \gets \kgen(\secparam, \maxdeg),\\
      & ((c_1, \ldots, c_k), \aux, z, (s_1, \ldots, s_k),\\
      & \qquad \qquad (o_1, \ldots, o_k)) \gets \adv^{\oracles, \ro}(\srs, r), \\
    \end{aligned}
  \right.\right]
  \geq 1 - \eps(\secpar).
\]
\end{definition}

\markulf{17.08}{
  We show how to construct $ \ext_\adv$ from $|Q_{H}|$ extractors $\ext_{\bdv_{i}}$ obtained from adversaries $\bdv_{i}$ that run $\adv$ by simulating the random oracle internally using its random tape. Only for the $i$th $\ro$ query, does $\bdv_{i}$ submit the challenge $c$ to $\oraclec$ to learn $z$. As $\bdv_{i}$ is a valid $\adv_{\mathsf{chal}}$ adversary, by $k$ simulation extractability of the polynomial commitment scheme $\ext_{\bdv_{i}}$ exists. $\ext_{\adv}$ runs all $\ext_{\bdv_{i}}$ and thus does not occure an extraction loss for guessing $i$.
}


 \begin{definition}[One-to-many openable\hl{Good name needed}]
   We call a commitment scheme $\PCOM$ one-to-many openable \hl{good name
     needed} if for any $\adv$ who outputs commitments $c_1, \ldots, c_k$,
   evaluation point $z$, evaluations $s_1, \ldots, s_k$ and batch opening $o$,
   which certifies that polynomials $f_i$ evaluates at $z$ to $s_i$ and
   $c_i \in \image(\com(f_i))$, there exists $\ppt$ algorithm $\bdv$ that
   produces valid openings $o_i$ for each triple $(c_i, z, s_i)$.
 \end{definition}
 Intuitively, we say that a polynomial commitment is one-to-many openable if we
 can deduce that adversary who successfully batch opens a number of polynomial
 commitments could also successfully open each of the commitments separately.

 \michals{23.06}{That's easy for KZG batched as in Plonk (with minor difference)
   -- just get a number of batch openings and do Gaussian elimination.}

 \begin{definition}
\hl{The proof system and the polynomial commitment scheme use virtually the same
SRS. (Both SRS could differ in some efficiency related elements, but computation
of these don't require any secret knowledge)}
\michals{12.07}{Check how it is done in Lunar}
\antonio{29.07}{I think you might want to look at Pag 71 of Lunar's manuscript, Definition 20.}
   \end{definition}

\subsection{Polynomial IOP}
 \begin{definition}[$\eps$-sufficiently simulatable PCOM]
   Let $\PCOM$ be a SE polynomial commitment scheme and
   $\PS = (\kgen, \prover, \verifier, \simulator)$ a polynomial zero-knowledge proof system
   for relation $\REL$. We call $\PCOM$ \emph{$\eps$-sufficiently simulatable for
     $\PS$} if there exist a $\ppt$ algorithm $\adv$ such that for
   $\srs \sample \kgen$, all $(\inp, \wit) \in \REL$ holds
   \[
     \SD_{\srs \sample \kgen(\secparam)}(\prover(\srs, \inp, \wit),
     \adv^{\oracles}(\srs, \inp)) \leq \eps(\secpar).
   \]
 \end{definition}
 Intuitively, we call $\PCOM$ sufficiently simulatable for $\PS$ if a $\ppt$
 $\adv$ given access to $\PCOM$'s simulator oracle $\oraclespcom$ can produce a
 simulated proof for $\PS$.
	\antonio{29.07}{If I understood correctly, $\PS$ should the ``compiled'' proof system,
		namely the PS obtained using polycommitment and an information-theoretic proof system
		(like a PHP),right? I don't really understand why you need this def.}

 \begin{definition}[Polynomial Holomorphic Proof System (PHP)]
  \label{def:php}
  Let $\REL$ be an indexed relation with a corresponding language $\LANG$, $\FF$
  some finite field, $\maxdeg$ a degree bound, $\vereq_{\cdot}(X) \in \FF[X]$ a
  verification equation, and $\eps, \noofp$ parameters.
  \michals{12.07}{Continue}
\end{definition}

\begin{definition}[Witness encoding PHP (WEPHP)]
  \label{def:wephp}
  Let $\PS$ be a PHP.  We say that $\PS$ is \emph{witness encoding} if there is
  a function $\decode$ and set $\encset \in [\noofp]$ such that for any
  $(\inp, \wit) \in \REL$ and polynomials $\smallset{f_i}_{i \in [\noofp]}$ sent by an
  honest prover, $\decode(\smallset{f_i}_{i \in \encset}) = \wit$. We call $\encset$ the
  \emph{encoding set}.
\end{definition}
In other words, PHP is witness encoding if for any valid proof for a statement
$\inp$ in the language, the corresponding witness can be read from the
polynomial coefficients. We note that this is the case for virtually all
PHPs. \michals{28.04}{Check!}

\antonio{27.07}{This definition reminded me that in Lunar we define straight-line extractability for PHP.
	The straight-line extractability def is stronger than def above but I think that every "natural" PHP should
	also be straight-line extractable. I copy-paste the definition below:}
	%
\begin{definition}[PHPs with straight-line extractor]
\label{def:knownsound_wc_poly}
A $\PS$ is $\epsilon$-knowledge-sound with straight-line extractor if there exists an
extractor $\WitExtract$ such that for any prover $\Pphp^*$, every field $\FF \in \Fam$,
relation $\ind$, and instance $\inp$: 
\[ \Prob{ (\ind, \inp, \WitExtract(\tuple\pora{\nprv})) \in \relfam}
	\geq \Prob{ \braket{ \Pphp^*,\Vphp^{\Iphp(\FF,\ind)}(\FF,\inp) } = 1} - \epsilon
\]
where $\tuple\pora{\nprv}$ are the polynomials output by $\Pphp^*$ in an execution of
$\braket{\Pphp^*, \Vphp^{\Iphp(\FF,\ind)}(\FF,\inp)}$.
\end{definition}



\begin{definition}[Somehow deterministic WEPHP]
  \label{def:sdwephp}
  Let $\PS$ be a WEPHP for $\REL$. For each polynomial $f_i$ sent by the prover
  denote by $A_i$ the set of challenges sent by the verifier and by $F_i$ the
  set of polynomials sent by the prover \emph{before} the prover sends
  $f_i$. Let $\encset$ be an encoding set. We say that $\PS$ is \emph{somehow
    deterministic} (SD) if for any $(\inp, \wit) \in \REL$, polynomials
  $\smallset{f_i}_{i \in [\noofp]}$ send by the prover, and encoding set
  $\encset \neq [\noofp]$ each polynomial
  $f_j \in \smallset{f_i}_{i \in [\noofp] \setminus \encset}$ is determined by
  \begin{itemize}
    \item polynomials $F_j$, and
    \item the verifier's challenges $A_i$, and
    \item the witness $\wit$.
  \end{itemize}
\end{definition}
Intuitively, we say that WEPHP is somehow deterministic if the only
non-deterministic messages send by the prover are polynomials encoding the
witness, and all other messages are determined by the previous one, witness, and
verifier's challenges.
\antonio{29.07}{Why do we need this definition?}
\michals{18.08}{I though we may need it to show simulation extractability, but I
am not sure anymore.}

\section{PHP-to-NIZK compiler}

\subsection{From PHP to zkPHP}
\michals{24.06}{Need to show how to get a ZK PHP from PHP}

\begin{theorem}[From WEPHP to ZK WEPHP]
  Let $\PHP = (\prover, \verifier)$ be a WEPHP and $E$ its encoding set,
  $\maxdeg$ be a maximal degree of polynomials sent by the prover; and
  let $\PHP = (\prover', \verifier')$ be a WEPHP such that
  \begin{itemize}
  \item Both parties get as input a set of $\FF$ elements $H$, such that
    $\abs{H} = \maxdeg + 1$. Denote the vanishing polynomial for $H$ by $\van{H}$.
  \item $\prover'$ acts as $\prover$ except for $f_i(X) \in E$. Let $k_i$ be a
    number of queries $\verifier$ makes to the oracle $\oracleo_{f_i}$ and
    $d_i = \deg(f_i)$, then $\prover'$ computes
      \[
        g_i(X) = f_i(X) + \van{H}\left(X^{d_i + 1} b_1 + \ldots
        X^{d_i + k_i + 1} b_{k_i + 1}\right)
      \]
      for random $b_1, \ldots, b_{k + 1}$ and sets oracle $\oracleo_{g_i}$.
    \item $\verifier'$ acts as $\verifier$. \michals{28.06}{We don't want to
        change the verifier and its equations -- that's why we have $\van{H}$.}
  \end{itemize}
\end{theorem}
\antonio{29.07}{How can we choose the set $H$? In other words, how do we select an $H$ that
does not mess with the completeness or the soundness of the PHP?
Can we just say that if the original PHP checks $G(X,h_1(v_1(X)),...)=0$ then the new PHP
checks $G(X,h'_1(v_1(X)),\dots)$ where $h'_i(X)=h'_i(X)+V_H(X)r_i(X)$ for some randomly
chosen $r_i$? ($V_H$ is the vanishing poly at $H$) I guess completeness would hold for any
$H$ but not sure about soundness, right?}
\michals{18.08}{$H$ is given. Need to think about the second part of your question.}
\begin{proof}
  \ncase{Completeness} 

  \ncase{Soundness} 

  \ncase{Zero-knowledge} To show the property we construct a simulator
  $\simulator$ and argue that it produces proofs indistinguishable from proofs
  of a real prover. The simulator behaves as real prover, except for
  witness-encoding polynomials in $\smallset{f_i}_{i \in E}$. For
  $f_j \in \smallset{f_i}_{i \in E}$, where it
  \begin{itemize}
  \item Picks randomizers $b_1, \ldots, b_{\noofq_j}$ and computes polynomial
    $g_i(X) =  \van{H}(b_1 X + \ldots b_{\noofq_j} X^{\noofq_j})$. 
  \item \michals{28.06}{The simulator can open the commitment to any value, but
      he need to know *which* value}
  \end{itemize}
  
\end{proof}

\subsection{Simulation extractable NIZKs from simulation extractable polynomial
  commitments}

\begin{theorem}
  Let $\PHP = (\PHP.\prover, \PHP.\verifier, \PHP.\simulator)$ be a ZK PHP
  for $\REL$ with knowledge soundness error $\epsks$ where the prover sends up
  to $\noofp$ polynomials. Let $\PCOM$ be $\eps(\secpar)$-sufficiently
  simulatable polynomial commitment scheme for $\PS$ with extraction error
  $\epsext$. Let $\PS = (\PS.\prover, \PS.\verifier, \PS.\simulator)$ be a proof system such
  that
  \begin{enumerate}
  \item $\PS.\prover$ acts as $\PHP.\prover$, except
    \begin{itemize}
    \item when $\PHP.\prover$ sets up a polynomial oracle $\oracleo_f$,
      $\PS.\prover$ sends commitment $c = \com(f)$;
    \item when $\PS.\verifier$ asks $\PS.\prover$ to open a commitment
      $c = \com(f)$ at $z$ it returns $f(z)$ and a proof $o$ of correctness of
      the opening.
  \end{itemize}
  \item $\PS.\verifier$ acts as $\PHP.\verifier$, except when $\PHP.\verifier$
    asks oracle $\oracleo_f$ for an evaluation of $f$ at $z$, $\PS.\verifier$
    sends $z$ to $\PS.\prover$ and expects $f(z)$ in return.
  \item $\PS.\simulator$ acts as $\PHP.\simulator$, except
     \begin{itemize}
    \item when $\PHP.\simulator$ sets up a polynomial oracle $\oracleo_f$,
      $\PS.\simulator$ sends commitment $c = \com(f)$;
    \item when $\PS.\verifier$ asks $\PS.\simulator$ to open a commitment
      $c = \com(f)$ at $z$ it returns $f(z)$ and a proof $o$ of correctness of
      the opening.
  \end{itemize}
  \end{enumerate}
  Then $\PS$ is simulation extractable with extraction error at most \hl{...}.
\end{theorem}
\begin{proof}
  From the simulation extractability of $\PCOM$ we will derive simulation
  extractability of $\PS$ by constructing a $\PS$ extractor $\ext^{\PS}$ using
  $\PCOM$ extractor $\ext^{\PCOM}$.

  Let $\adv(\srs)$ be a $\PS$ adversary with oracle access to a $\PS$ simulator
  $\simulator$. We show construction of an extractor $\ext^{\PS}$ which from
  acceptable proof $\zkproof$ for instance $\inp$ output by $\adv$ produces
  witness $\wit$ such that $\REL(\inp, \wit) = 1$. We proceed by game hoping.
  
  \ngame{1} Let $\ext^{\PS}_\adv$ be an extractor for adversary $\adv$. In this
  game the adversary is given oracle $\oraclesps$ and produces an instance
  $\inp$ and proof $\zkproof$. $\adv$ wins if $\ext_\adv$ does not output the
  corresponding witness $\wit$.

  \ngame{2} In this game $\adv$'s access to $\oraclesps$ is substituted by
  access to $\bdv^\oraclespcom$ which simulates $\oraclesps$.
  Since $\PCOM$ is sufficiently simulatable for $\PS$, probability that $\adv$
  wins in Game $\game{1}$ but not in $\game{2}$ (or vice-versa) is at most
  $\eps(\secpar)$.

  \medskip\noindent We now analyze the probability that $\adv$ wins in Game
  $\game{2}$. Since $\PCOM$ is simulation extractable, there exists an extractor
  $\ext_\bdv$ which extracts, for $i \in \range{1}{\noofp}$, polynomials $f_i$
  if $\bdv$ output
  \begin{inparaenum}[(1)]
  \item commitment $c_i$ and $c_i \in \image(\com(f_i))$;
  \item evaluations $s_i$ for evaluation points $z_i$ provided by the $\PS.\verifier$;
  \item openings $o_i$;
  \end{inparaenum}
  \michals{28.06}{Stopped here -- we need more details of PHP to argue about
    $\bdv$ returning a valid opening of commitment. Further we want to state
    that if the proof was accepted then the commitments have been opened
    successfully. If the proof system allow for batch opening, then still we can
  open every single commitment.}
  
\end{proof}
\newcommand{\Kzg}{\mathsf{KZG}}
%\newcommand{\kzg}{\mathsf{kzg}}

\def\cgen{{\sf ComGen}}
\def\commit{{\sf Com}}
%\def\comopen{{\sf ComOpen}}
%\def\openver{{\sf OpenVer}}
% \newcommand{\comkg}{\mathsf{KG}}
%\newcommand{\PC}{\mathsf{PC}}
\newcommand{\CM}{\commit}

%\def\open{{\sf Open}}
\def\check{{\sf Check}}
%\def\witness{{\sf wit}}
\def\gk{{\sf gk}}

\def\ck{{\sf ck}}
\newcommand{\secp}{\lambda}

\section{KZG commitments are simulation extractable}
$\Kzg.\PC = (\Kzg.\kgen, \Kzg.\com, \Kzg.\open, \Kzg.\verify)$ is defined over bilinear groups $\gk=(p,\GG_1,\allowbreak \GG_2, \allowbreak \GG_T )$ with $\GG_1 =\langle g\rangle, \GG_2 =\langle h \rangle$ as follows:
\begin{description}%[topsep=5pt]
\item[$\Kzg.\kgen(1^\secpar, n) \to \srs$:] Set keys
$\srs = \{g^{\alpha^i}\}_{i=0}^{n-1}, h^\alpha$.
\item[$\Kzg.\CM(\srs; f(X)) \to c$:] For
  $f(X) = \sum_{i=0}^{n-1} f_i X^i$, computes
  $c=\prod _{i=0}^{n-1} g^{f_i \alpha^i} = g^{f(\alpha)} $.
\item[$\Kzg.\open(\srs; c, x, y; f(X)) \to \pi$:] For an evaluation point
  $x$, a value $y$, compute the quotient polynomial
  $q(X) = \displaystyle\frac{f(X) -y }{X-x}$ and output a proof
  $\pi = C_q = \Kzg.\CM(\srs; q(X)) $.
\item[$\Kzg.\verify(\srs, c, x, y, \pi) \to 1/0$:] Check if
  $e(c \cdot g^{-y}, h)=e(\pi , h^{\alpha}\cdot h^{-x})$.
\end{description}

We move toward considering a symbolic verification equation $V'$ for which we have:
$V(c,x,y,\pi) =  e(c \cdot  g^{-y}, h) - e(\pi , h^{\alpha}\cdot h^{-x}) = 0$ iff $V'(K * Transcript (T)) = 0$.

The trapdoors variables $T$ consist of the trapdoor variable $X$ of the setup and the randomness variables $A_{i}$ of simulated proofs:
$T=(X, \{A_{i}\})$

The transcript consists of the setup $\{[X^{i}]_{1}\}, [X]_{2}$ and simulated proofs $\{[A_{i} + y_{i}]_{1}, [\frac{A_{i}}{X-x_{i}}]\}$.

The honest verification equation is
$[f(X) - y]_1 \circ [h]_{2} - [q(X)]_1 \circ [X-x]_{2}=0$ while an adversary can
provide rational functions
$f(X, \{A_{i}\}) = \sum C_{1i} X^{i} + \sum C_{2i} A_{i} + \sum C_{3i}
\frac{A_{i}}{X-x_{i}}$ and
$q(X, \{A_{i}\}) = \sum Q_{1i} X^{i} + \sum Q_{2i} A_{i} + \sum Q_{3i}
\frac{A_{i}}{X-x_{i}}$ computed as linear combinations of elements in the
transcript. Note that we performed a simplification here as the $y_{i}$ are
picked and known by the adversary.

The security game gives us that $x \neq x_{i}$.

We inline to get the following equation which we then analyze in detail,
\begin{align*}
  \left[\sum C_{1i} X^{i} + \sum C_{2i} A_{i} + \sum C_{3i} \frac{A_{i}}{X-x_{i}} - y\right]_{1} \circ [1]_{2} - \left[\sum Q_{1i} X^{i} + \sum Q_{2i} A_{i} + \sum Q_{3i} \frac{A_{i}}{X-x_{i}}\right]_{1} \circ [X-x]_{2} = 0
  \end{align*}

We now look at diferent monomials in $T$ of this equation to derive constraints on $C_{ji}$ and $Q_{ji}$ imposed by the verification equation:
\begin{itemize}
  \item[$A_{i}X$:] $Q_{2i} A_{i} X = 0$
  \item[$A_{i}$:] $C_{2i} A_{i} = - Q_{2i}A_{i} x$. As $Q_{2i}=0$, it follows
    that $C_{{2i}}=0$. This step relies on $x \neq x_{i}$ and thus
    $\frac{A_{i} (X-x)}{X-x_{i}}$ cannot cancel out its denominator.
  \item[$\frac{A_{i}X}{X-x_{i}}$:] $Q_{3i} \frac{A_{i} X}{X-x_{i}} = 0$.
  \item[$\frac{A_{i}}{X-x_{i}}$:]
    $C_{3i} \frac{A_{i}}{X-x_{i}} = Q_{{3i}} \frac{A_{i}}{X-x_{i}} $. As
    $Q_{3i}=0$, it follows that $C_{{3i}}=0$.
  \end{itemize}
We are thus back to the honest verification equation.

\section{Simulation extractable NIZK from a simulation extractable polynomial
  commitment and polynomial protocol}
Here we show that given a simulation extractable polynomial commitment scheme
and polynomial protocol one can use the polynomial protocol-to-NIZK compiler
from \cite{EPRINT:GabWilCio19} to get a simulation extractable NIZK. The idea of
the construction is following. First we observe that since the polynomial
commitment is simulation extractable then for every adversary $\bdv$ who, given
access to a polynomial commitment simulator oracle $\oraclespcom$, outputs a
vector of commitments $\vec{c} = (c_1, \ldots, c_\ell)$ and its valid opening $\vec{o}$ at random points
$\vec{z}$, there exists an
extractor $\ext_\bdv$ which, given
\begin{itemize}
\item $\bdv$'s code,
\item its randomness $r_\bdv$, and
\item auxiliary input $\aux_\bdv$, where $\aux_\bdv$ consists of all
  $\oraclespcom$'s responses for $\bdv$ queries
\end{itemize}
outputs $\vec{f}$ such that $c_i \in \image(\com(f_i))$, for
$i \in \range{1}{\ell}$.  Then we take a simulation-extractability adversary for
the compiled NIZK $\adv$ and build its corresponding extractor $\ext_\adv$ using
$\bdv$ and $\ext_\bdv$.

More precisely, we show that $\adv$'s access to $\oraclesps$ can be substituted
with some \emph{deterministic} algorithm $\bdv$ and $\oraclespcom$. We then
build $\ext_\adv$ using $\bdv$ and $\ext_\bdv$. To do that we need
to ``translate'' $\ext_\adv$'s inputs as $\ext_\bdv$'s inputs. From a high level
perspective this is achieved as follows:
\begin{description}
\item[$\bdv$'s code:] $\bdv$ code compounds of two elements: a subroutine that
  runs $\adv$ and an overlay $\cdv$ that is responsible for providing $\adv$ with
  simulated proofs using its access to $\oraclespcom$. More precisely on
  $\adv$'s query to $\oraclesps$ $\cdv$ parses it as a set of $\oraclespcom$
  queries, then it parses oracle's responeses to make a $\PS$ proof out of
  them. Such proof is send back to $\adv$. Hence, $\bdv$'s code composes of code
  of $\adv$ and some (publicly known and universal, i.e.~one for all $\adv$'s)
  code of algorithm $\cdv$. 
\item[$\bdv$'s randomness:] Since $\cdv$ is deterministic, we have
  $r_\adv = r_\bdv$.
\item[Auxiliary input $\aux_\bdv$:] Since the simulated proofs from $\oraclesps$
  collected in $\aux_\adv$ compounds of polynomial commitments, their evaluation
  and openings, they can be naturally translated to a number of $\oraclespcom$
  calls.
\end{description}
After the extractor $\ext_\bdv$ produces an output -- a vector of polynomials --
$\ext_\adv$ needs to parse it to its needs. To that end, it makes $\PS$'s proofs
out of them.

\begin{lemma}[Trapdoor-free simulatability of polynomial protocols.]
  Let $\PS$ be a polynomial protocol with verification equation
  \[
    \vereq := G(X, h_1(v_1(X)), \ldots, h_\ell(v_\ell (X))) = 0.
  \]
  Assume that for all $i, j, k, l \in \range{1}{\ell}$, $a_j, a_{k, l} \in \FF$ holds
  \[
    h_i(v_i(X)) \neq a_j h_j(v_j(X)) + \sum_{k, l} a_{k, l} h_k(v_k (X)) h_l (v_l (X)),
  \]
  additionaly assume uber assumption \cite{}.
  Then there exists simulator $\simulator$ such that for any $\ppt$ adversary
  $\adv$
  \[
    \text{no polynomial adversary can distinguish the proofs -- computational ZK}
  \]
\end{lemma}
\begin{proof}[draft]
  The simulation idea is similar to the one presented in
  \cite{EPRINT:CFFQR20}. When $\prover$ sends a polynomial commitment $c$ to
  some polynomial $f$, the simulator picks a random commitment
  $c_\simulator$. When all commitments have been submitted, the simulator
  computes $ G(X, h_1(v_1(X)), \ldots, h_\ell(v_\ell (X)))$ and finds its root
  $\chz$. Then it programs the random oracle to return $\chz$ as the polynomial
  protocol challenge.

  First, since the uber assumption holds, no $\ppt$ algorithm can tell
  commitment to a randomly picked $f$ from a real one. \michals{28.07}{Here we
    assume that $\PCOM$ is the KZG scheme but it should be generalizable to any
    polynomial commitment.} Also, relaying on the same assumption, no $\ppt$
  algorithm can tell evaluation of $f$ at a random point from an evaluation of a
  random polynomial.
  Furthermore, since the simulator picks $\chz$ such that verification equation
  holds, the verifier accepts such proof. \michals{28.07}{Probably need to argue
    that $\chz$, which the simulator picks also ``looks random''.}
  \qed
\end{proof}

\begin{theorem}[From simulation extractable $\PCOM$ to simulation extractable $\nizk$.]
\end{theorem}
\begin{proof}
  \qed
\end{proof}


\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev1,cryptobib/crypto}

\appendix
\section{Additional assumptions}
\subsection{On uber assumption}
\begin{definition}[$(m, F)$-independent polynomial]
  Let $F = \smallset{f_1, \ldots, f_k}$ be a family of polynomials. We say that $g$ is \emph{$2$-independent
    from $F$} if
  \[
    a_h h(X) = \sum_{i_1 = 1}^{k} a_{i_1} f_{i_1} + \sum_{i_1, i_2}^{k, k} a_{i_1, i_2}
    f_{i_1} f_{i_2} + \ldots \sum_{i_1, \ldots, i_m}^{k, \ldots, k} a_{i_1,
      \ldots, i_m} f_{i_1} \ldots f_{i_m},
  \]
  only iff all coefficients $a_h$, $a_{i_1}$, $a_{i_1, i_2}$, \ldots, $a_{i_1},
  \ldots, a_{i_m}$ are zero. 
\end{definition}

In this paper we consider only case of $m = 2$. For that case we ``fine tune''
the definition above and allow two different families of polynomials that $h$ is
independent from. That is,

\begin{definition}[$(2, F, G)$-independent polynomial]
  Let $F = \smallset{f_1, \ldots, f_k}$, $G = \smallset{g_1, \ldots, g_l}$ be
  families of polynomials. We say that $h$ is \emph{$(2, F, G)$-independent} if
  \[
    a_h h(X) = \sum_{i = 1}^{k} a_{i} f_{i} + \sum_{i}^l b_{i} g_i + \sum_{i, j}^{k, l} c_{i, j}
    f_{i} g_{j},
  \]
  only iff all coefficients $a_h$, $a_{i}$, $b_i$, $c_{i, j}$ are zero. 
\end{definition}
This definition is equivalen to definition of independent polynomials from
\cite{PAIRING:Boyen08}.

\begin{definition}[Independent proof elements]
  Let $\PHP$ be a PHP proof system, and $f_1, \ldots, f_l$ all polynomials sent
  by the prover. 
\end{definition}


 \section{Unoptimized $\plonk$ with arbitrary polynomial commitment $\PCOM$}
 In the following we assume either
 \begin{enumerate}
 \item the polynomial commitments $\PCOM$ is $l$-hiding, or \michals{16.08}{$l$
    -hiding -- impossible to tell commitments to two polynomials given up to $l$
  evaluations}
 \item \hl{...} uber assumption holds \michals{16.08}{the distinguisher cannot
     tell a commitment to a random polynomial (case of simulated proof) from a
     commitment to a specific polynomial (that is not in the span of SRS
     polynomials, case of a real proof)}
 \end{enumerate}
 that the polynomial commitment has one of the
 following prope
 \subsection{$\plonk$ protocol rolled out}
\label{sec:plonk_explained}
\newcommand{\vql}{\vec{q_{L}}}
\newcommand{\vqr}{\vec{q_{R}}}
\newcommand{\vqm}{\vec{q_{M}}}
\newcommand{\vqo}{\vec{q_{O}}}
\newcommand{\vx}{\vec{x}}
\newcommand{\vqc}{\vec{q_{C}}}
\subsubsection{The constrain system}
Assume $\CRKT$ is a fan-in two arithmetic circuit,
which fan-out is unlimited and has $\numberofconstrains$ gates and $\noofw$ wires
($\numberofconstrains \leq \noofw \leq 2\numberofconstrains$). \plonk's constraint
system is defined as follows:
\begin{itemize}
\item Let $\vec{V} = (\va, \vb, \vc)$, where $\va, \vb, \vc
  \in \range{1}{\noofw}^\numberofconstrains$. Entries $\va_i, \vb_i, \vc_i$ represent indices of left,
  right and output wires of circuits $i$-th gate.
\item Vectors $\vec{Q} = (\vql, \vqr, \vqo, \vqm, \vqc) \in
  (\FF^\numberofconstrains)^5$ are called \emph{selector vectors}:
  \begin{itemize}
  \item If the $i$-th gate is a multiplicative gate then $\vql_i = \vqr_i = 0$,
    $\vqm_i = 1$, and $\vqo_i = -1$. 
  \item If the $i$-th gate is an addition gate then $\vql_i = \vqr_i  = 1$, $\vqm_i =
    0$, and $\vqo_i = -1$. 
  \item $\vqc_i = 0$ always. 
  \end{itemize}
\end{itemize}

We say that vector $\vx \in \FF^\noofw$ satisfies constraint system if for all $i
\in \range{1}{\numberofconstrains}$
\[
  \vql_i \cdot \vx_{\va_i} + \vqr_i \cdot \vx_{\vb_i} + \vqo \cdot \vx_{\vc_i} +
  \vqm_i \cdot (\vx_{\va_i} \vx_{\vb_i}) + \vqc_i = 0. 
\]

\subsubsection{Algorithms rolled out}
\label{sec:plonk_explained}
\plonk{} argument system is universal. That is, it allows to verify computation
of any arithmetic circuit which has no more than $\numberofconstrains$
gates using a single SRS. However, to make computation efficient, for each
circuit there is allowed a preprocessing phase which extend the SRS with
circuit-related polynomial evaluations.

For the sake of simplicity of the security reductions presented in this paper, we
include in the SRS only these elements that cannot be computed without knowing
the secret trapdoor $\chi$. The rest of the SRS---the preprocessed input---can
be computed using these SRS elements thus we leave them to be computed by the
prover, verifier, and simulator.

\paragraph{$\plonk$ SRS generating algorithm $\kgen(\REL)$:}
The SRS generating algorithm picks at random $\chi \sample \FF_p$, computes
and outputs
\[
	\srs \gets \PCOM.\kgen(\secparam).
\]

\paragraph{Preprocessing:}
Let $H = \smallset{\omega^i}_{i = 1}^{\numberofconstrains }$ be a
(multiplicative) $\numberofconstrains$-element subgroup of a field $\FF$
compound of $\numberofconstrains$-th roots of unity in $\FF$. Let $\lag_i(X)$ be
the $i$-th element of an $\numberofconstrains$-elements Lagrange basis. During
the preprocessing phase polynomials $\p{S_{id j}}, \p{S_{\sigma j}}$, for
$\p{j} \in \range{1}{3}$, are computed:
\begin{equation*}
  \begin{aligned}
    \p{S_{id 1}}(X) & = X,\vphantom{\sum_{i = 1}^{\noofc} \sigma(i) \lag_i(X),}\\
    \p{S_{id 2}}(X) & = k_1 \cdot X,\vphantom{\sum_{i = 1}^{\noofc} \sigma(i) \lag_i(X),}\\
    \p{S_{id 3}}(X) & = k_2 \cdot X,\vphantom{\sum_{i = 1}^{\noofc} \sigma(i) \lag_i(X),}
  \end{aligned}
  \qquad
\begin{aligned}
  \p{S_{\sigma 1}}(X) & = \sum_{i = 1}^{\noofc} \sigma(i) \lag_i(X),\\
  \p{S_{\sigma 2}}(X) & = \sum_{i = 1}^{\noofc}
  \sigma(\noofc + i) \lag_i(X),\\
  \p{S_{\sigma 3}}(X) & =\sum_{i = 1}^{\noofc} \sigma(2 \noofc + i) \lag_i(X).
\end{aligned}
\end{equation*}
Coefficients $k_1$, $k_2$ are such that $H, k_1 \cdot H, k_2 \cdot H$ are
different cosets of $\FF^*$, thus they define $3 \cdot \noofc$
different elements. \cite{EPRINT:GabWilCio19} notes that it is enough to set
$k_1$ to a quadratic residue and $k_2$ to a quadratic non-residue.

Furthermore, we define polynomials $\p{q_L}, \p{q_R}, \p{q_O}, \p{q_M}, \p{q_C}$
such that
\begin{equation*}
  \begin{aligned}
  \p{q_L}(X) & = \sum_{i = 1}^{\noofc} \vql_i \lag_i(X), \\
  \p{q_R}(X) & = \sum_{i = 1}^{\noofc} \vqr_i \lag_i(X), \\
  \p{q_M}(X) & = \sum_{i = 1}^{\noofc} \vqm_i \lag_i(X),
\end{aligned}
\qquad
\begin{aligned}
  \p{q_O}(X) & = \sum_{i = 1}^{\noofc} \vqo_i \lag_i(X), \\
  \p{q_C}(X) & = \sum_{i = 1}^{\noofc} \vqc_i \lag_i(X). \\
  \vphantom{\p{q_M}(X)  = \sum_{i = 1}^{\noofc} \vqm_i \lag_i(X),}
\end{aligned}
\end{equation*}

\paragraph{$\plonk$ prover
  $\prover(\REL, \srs, \inp, \wit = (\wit_i)_{i \in \range{1}{3 \cdot
      \noofc}})$.}
\begin{description}
\item[Round 1] Sample $b_1, \ldots, b_9 \sample \FF_p$; compute
  $\p{a}(X), \p{b}(X), \p{c}(X)$ as
	\begin{align*}
		\p{a}(X) &= (b_1 X + b_2)\p{Z_H}(X) + \sum_{i = 1}^{\noofc} \wit_i \lag_i(X) \\
		\p{b}(X) &= (b_3 X + b_4)\p{Z_H}(X) + \sum_{i = 1}^{\noofc} \wit_{\noofc + i} \lag_i(X) \\
		\p{c}(X) &= (b_5 X + b_6)\p{Z_H}(X) + \sum_{i = 1}^{\noofc} \wit_{2 \cdot \noofc + i} \lag_i(X) 
	\end{align*}
	Output polynomial commitments $\PCOM.\com(\p{a}(X)), \PCOM.\com(\p{b}(X)), \PCOM.\com(\p{c}(X))$.
	
	\item[Round 2]
	Get challenges $\beta, \gamma \in \FF_p$
	\[
		\beta = \ro(\zkproof[0..1], 0)\,, \qquad \gamma = \ro(\zkproof[0..1], 1)\,.
	\]
	Compute permutation polynomial $\p{z}(X)$
	\begin{multline*}
		\p{z}(X) = (b_7 X^2 + b_8 X + b_9)\p{Z_H}(X) + \lag_1(X) + \\
			+ \sum_{i = 1}^{\noofc - 1} 
			\left(\lag_{i + 1} (X) \prod_{j = 1}^{i} 
			\frac{
			(\wit_j +\beta \omega^{j - 1} + \gamma)(\wit_{\noofc + j} + \beta
      \omega^{\noofc + j - 1} + \gamma)(\wit_{2 \noofc + j} +\beta \omega^{2
        \noofc + j- 1} + \gamma)}
			{(\wit_j+\sigma(j) \beta + \gamma)(\wit_{\noofc + j} + \sigma(\noofc + j)\beta + \gamma)(\wit_{2 \noofc + j} + \sigma(2 \noofc + j)\beta + \gamma)}\right)
	\end{multline*}
	Output polynomial commitment $\PCOM.\com(\p{z}(X))$
		
	\item[Round 3]
	Get the challenge $\alpha = \ro(\zkproof[0..2])$, compute the quotient polynomials 
\begin{align*}
	\p{t_1}(X) & = (\p{a}(X) \p{b}(X) \selmulti(X) + \p{a}(X) \selleft(X) + 
               \p{b}(X)\selright(X) + \p{c}(X)\seloutput(X) + \pubinppoly(X) + \selconst(X)) 
               \frac{1}{\p{Z_H}(X)} \\
	\p{t_2}(X) & = ((\p{a}(X) + \beta X + \gamma) (\p{b}(X) + \beta \omega^{\noofc} X + \gamma)(\p{c}(X) 
               + \beta \omega^{2 \noofc} X + \gamma)\p{z}(X)) \frac{1}{\p{Z_H}(X)} \\
             & - (\p{a}(X) + \beta \p{S_{\sigma 1}}(X) + \gamma)(\p{b}(X) + \beta 
               \p{S_{\sigma 2}}(X) + \gamma)(\p{c}(X) + \beta \p{S_{\sigma 3}}(X) + 
               \gamma)\p{z}(X \omega))  \frac{1}{\p{Z_H}(X)} \\
	\p{t_3}(X) & =  (\p{z}(X) - 1) \lag_1(X) \frac{1}{\p{Z_H}(X)}
\end{align*}
Output $\cp{t_i} = \p{t_i}(\chi)$, for $i \in \range{1}{3}$.
	
\item[Round 4] Get the challenge $\chz \in \FF_p$, $\chz = \ro(\zkproof[0..3])$.
  Output evaluations
	\begin{align*}
    & \ev{a} = \p{a}(\chz), \ev{b} = \p{b}(\chz), \ev{c} = \p{c}(\chz),
    \ev{S_{\sigma, 1}}= \p{S_{\sigma 1}}(\chz), \ev{S_{\sigma 2}} = \p{S_{\sigma 2}}(\chz),  \\
    & \ev{z} = \p{z}(\chz), \ev{z_\omega} = \p{z}(\chz \omega),
    \ev{t_1} = \p{t_1}(\chz), \ev{t_2} = \p{t_2}(\chz), \ev{t_3} = \p{t_3}(\chz)
	\end{align*}
	
	\item[Round 5]
	Compute the opening challenge $v \in \FF_p$, $v = \ro(\zkproof[0..4])$.
	Compute the openings for the polynomial commitment scheme
  \michals{11.08}{Need to add that commitment scheme is additively homomorphic}
  \begin{align*}
    & \p{W_\chz^{t_1}} = \PCOM.\open(\srs, \cp{t_{1}}, \p{t_1}(\chz)) \\
    & \p{W_\chz^{t_2}} = \PCOM.\open(\srs, \cp{t_{2}}, \p{t_2}(\chz)), \\
    & \p{W_\chz^{t_3}} = \PCOM.\open(\srs, \cp{t_{3}}, \p{t_3}(\chz)), \\
 %  & \p{W_\chz^{\p{r}}} = \PCOM.\open(\srs, \cp{r}, \p{r}(\chz)), \\
    & \p{W_\chz^{\p{a}}} = \PCOM.\open(\srs, \cp{a}, \p{a}(\chz)), \\
    & \p{W_\chz^{\p{b}}} = \PCOM.\open(\srs, \cp{b}, \p{b}(\chz)), \\
    & \p{W_\chz^{\p{c}}} = \PCOM.\open(\srs, \cp{c}, \p{c}(\chz)), \\
    & \p{W_\chz^{\p{S_{\sigma 1}}}} = \PCOM.\open(\srs, \cp{S_{\sigma 1}}, \p{S_{\sigma 1}}(\chz)), \\
    & \p{W_\chz^{\p{S_{\sigma 2}}}} = \PCOM.\open(\srs, \cp{S_{\sigma 2}}, 
      \p{S_{\sigma 2}}(\chz)), \\
    & \p{W_{\chz}^{\p{z}}} = \PCOM.\open(\srs, \cp{z}, \p{z}(\chz)) \\
    & \p{W_{\chz \omega}^{\p{z}}} = \PCOM.\open(\srs, \cp{z}, \p{z}(\chz \omega))
 \end{align*}
 Output the computed polynomial commitment openings.
\end{description}

\ncase{$\plonk$ verifier $\verifier(\REL, \srs, \inp, \zkproof)$}\ \newline
The \plonk{} verifier works as follows
\begin{description}
	\item[Step 1] Validate all obtained group elements.
	\item[Step 2] Validate all obtained field elements.
	\item[Step 3] Validate the instance $\inp = \smallset{\wit_i}_{i =
      1}^\ell$.%instsize.
	\item[Step 4] Compute challenges $\beta, \gamma, \alpha, \chz, v,
    u$ from the transcript.
	\item[Step 5] Compute zero polynomial evaluation
      $\p{Z_H} (\chz) =\chz^\noofc - 1$.
	\item[Step 6] Compute Lagrange polynomial evaluation
      $\lag_1 (\chz) = \frac{\chz^\noofc -1}{\noofc (\chz - 1)}$.
    \item[Step 7] Compute public input polynomial evaluation $\pubinppoly (\chz)
      = \sum_{i \in \range{1}{\instsize}} \wit_i \lag_i(\chz)$.
	\item[Step 8] Compute evaluations of constraint polynomial and
    permutation-argument polynomial
\begin{align*}
	\ev{t_1} & = (\ev{a} \ev{b} \selmulti(\chz) + \ev{a}(\chz) \selleft(\chz) + 
             \ev{b}\selright(\chz) + \ev{c}\seloutput(\chz) + \pubinppoly(\chz) + \selconst(\chz)) 
             \frac{1}{\p{Z_H}(\chz)} \\
	\ev{t_2} & = ((\ev{a} + \beta \chz + \gamma) (\ev{b} + \beta \omega^{\noofc} \chz + \gamma)(\ev{c} 
             + \beta \omega^{2 \noofc} \chz + \gamma)\ev{z} \frac{1}{\p{Z_H}(\chz)} \\
           & - (\ev{a} + \beta \ev{S_{\sigma 1}} + \gamma)(\ev{b} + \beta 
             \ev{S_{\sigma 2}} + \gamma)(\ev{c} + \beta \ev{S_{\sigma 3}} + 
             \gamma)\ev{z_{\omega}}(\chz \omega))  \frac{1}{\p{Z_H}(\chz)} \\
	\ev{t_3} & =  (\ev{z} - 1) \lag_1(\chz) \frac{1}{\p{Z_H}(\chz)}
\end{align*}
\item[Step 9] Verify all polynomial commitment openings.
\end{description}

% \ncase{$\plonk$ simulator $\simulator_\chi(\REL, \srs, \td= \chi, \inp)$}\ \newline
% The \plonk{} simulator proceeds as an honest prover would, except:
% \begin{enumerate}
%   \item In the first round, it sets $\wit = (\wit_i)_{i \in \range{1}{3 \noofc}}
%     = \vec{0}$, and at random picks $b_1, \ldots, b_9$. Then it proceeds with
%     that all-zero witness.
%   \item In Round 3, it computes polynomials $\p{t_1}(X), \p{t_2}(X), \p{t_3}(X)$
%     honestly (i.e.~according to the picked values), computes polynomial
%     evaluations $\ev{t_1}(\chz), \ev{t_2}(\chz), \ev{t_3}(\chz)$ as an honest
%     verifier computes and uses trapdoor $\chi$ to compute commitments
%     $\p{t_{lo, 1}}(\chi), \p{t_{mid, 1}}(\chi), \p{t_{hi, 1}}(\chi), \p{t_{lo,
%         2}}(\chi), \p{t_{mid, 2}}(\chi), \p{t_{hi, 2}}(\chi), \p{t_{lo,
%         3}}(\chi), \p{t_{mid, 3}}(\chi), \p{t_{hi, 3}}(\chi)$.
%   \end{enumerate}

\ncase{$\plonk$ trapdoor-less simulator $\simulator(\REL, \srs, \inp)$}\ \newline
The \plonk{} simulator proceeds as an honest prover would, except:
\begin{enumerate}
\item In the first round, it sets
  $\wit = (\wit_i)_{i \in \range{1}{3 \noofc}} = \vec{0}$, and at random picks
  $b_1, \ldots, b_9$. Then it proceeds with that all-zero witness.
\item In Round 3, it picks randomly challenge $\chz$, computes polynomial
  evaluations $\ev{t_i} = \p{t_i}(\chz)$, for $i \in \range{1}{3}$, and picks
  random polynomials $\p{t'_i}(X)$ such that $\p{t'_i}(\chz) = \p{t_i}(\chz)$
  and commits to them.
\end{enumerate}
 
We write $\PS^{\PCOM}$ to denote a proof system compiled from a PHP $\PHP$ using
polynomial commitment $\PCOM$. E.g., we denote non-interactive version of
$\plonk$ proof system by $\plonkprotfs^{\kzg}$, where $\kzg$ denotes the KZG
polynomial commitment scheme.

\begin{theorem}
  Let $\PCOM$ be a $(3, \eps)$-aux-simulation-extractable polynomial commitment,
  then $\plonkprotfs^{\PCOM}$ is $()$-simulation extractable.
  \michals{16.08}{$(3, \eps)$-aux-simulation-extractable -- $3$ polynomials are
    extracted, $1 - \eps$ is probability of extractor's success, aux -- see how
    we compute the challenge}
\end{theorem}
\begin{proof}
  \ncase{Game 0} Let $\adv^{\oraclesps}(\srs, \srss, \radv)$ be a SE adversary
  for $\plonkprotfs^{\PCOM}$
  \michals{20.08}{Continue -- that's a standard SE game here.}
    
  \ncase{Game 1} Let $\bdv^{\oraclespcom}(\srs_{\PCOM}, \rbdv)$ be a SE-PCOM
  adversary. We show how to use extractor
  $\ext_\bdv(\srs_{\PCOM}, \qbdv, \rbdv)$, where $\qbdv$ is a list of all
  queries to $\oraclespcom$ and their responses, to build extractor
  $\ext_\adv(\srs, \srss, \qadv, \radv)$, where $\qadv$ is a list of all queries
  to $\oraclesps$ and their responses, outputs witness $\wit$ such that
  $\REL(\inp, \wit) = 1$.

  We may equip adversary $\bdv$ with $\adv$'s code and its randomness
  $\radv$. More precisely, we hardcode $\adv$'s code into $\bdv$ and set
  $\rbdv = \radv$. (Importantly $\bdv$ does not use any randomness on its
  own). Such $\bdv$ proceeds as follows
  \begin{enumerate}
  \item Given $\PCOM$ reference string $\srs_{\PCOM}$, prepare $\PS$'s master
    SRS $\srs$ and specialized SRS $\srss$.
  \item Start $\adv(\srs, \srss, \radv)$.
  \item On each $\adv$'s query $(\inp, \wit)$ to $\oraclesps$:
    \begin{enumerate}
    \item Check $\REL(\inp, \wit) = 1$ and ignore if that's not the case.
    \item Prepare a simulated proof for $\adv$ using $\oraclespcom$, that is
      \begin{itemize}
      \item Ask $\oraclespcom$ for 7 commitments to random polynomials, denote
        the commitments by
        $\cp{a}, \cp{b}, \cp{c}, \cp{z}, \cp{t'_1}, \cp{t'_2}, \cp{t'_3}$.
      \item Compute random elements $\alpha, \beta, \gamma, \delta, \chz$ as
        random oracle evaluations at partial transcripts.
      \item Ask $\oraclespcom$ to evaluate all the polynomials at $\chz$ and get
        openings $W^{\p{f}}_\chz$, for
        $\p{f} \in \smallset{\p{a}, \p{b}, \p{c}, \p{z}}$.
      \item Ask $\oraclespcom$ to evaluate $\p{z}$ at $\omega \chz$ and get
        openings $W^{\p{z}}_{\omega \chz}$.
      \item Compute evaluations $\p{S_{\sigma 1}}(\chz)$,
        $\p{S_{\sigma 2}}(\chz)$ and openings $W^{\p{S_{\sigma 1}}}_\chz$,
        $W^{\p{S_{\sigma 2}}}_\chz$.
      \item For $i \in \range{1}{3}$, compute values of $\p{t_i}(\chz)$ as
        defined by the proof.
      \item For $i \in \range{1}{3}$, ask $\oraclespcom$ to evaluate $\cp{t'_i}$
        to open $\p{t'_i}(\chz)$ to $\p{t_i}(\chz)$.
      \item From the obtained commitments, evaluations, openings, and random
        elements compute a simulated proof $\zkproof$ for $\inp$.
      \end{itemize}
    \item Add $(\inp, \zkproof)$ to $\qadv$.
    \end{enumerate}
  \item On $\adv$'s challenge instance $\inp$ and proof $\zkproof$.
    \begin{enumerate}
    \item Parse $\zkproof$ to obtain
      \begin{itemize}
      \item commitments
        $\cp{a}, \cp{b}, \cp{c}, \cp{z}, \cp{t_1}, \cp{t_2}, \cp{t_3}$,
      \item random elements $\alpha, \beta, \gamma$,
      \item openings $W_\chz^{\p{a}}, W_\chz^{\p{b}}, W_\chz^{\p{c}}$.
      \end{itemize}
    \item Compute
      $\aux = (\cp{a}, \cp{b}, \cp{c}, \beta, \gamma, \cp{z}, \alpha, \cp{t_1},
      \cp{t_2}, \cp{t_3})$.
    \item Output
      \begin{itemize}
      \item commitments $\cp{a}$, $\cp{b}$, $\cp{c}$,
      \item auxiliary input $\aux$,
      \item challenge $z = \ro(\aux)$,
      \item openings $W_z^{\p{a}} := W_\chz^{\p{a}}$,
        $W_z^{\p{b}} := W_\chz^{\p{a}}$, $W_z^{\p{c}} := W_\chz^{\p{c}}$.
      \end{itemize}
    \end{enumerate}
  \end{enumerate}
  \michals{16.08}{Open questions: (1) How to use adversary $\bdv$ that is tasked
    to output only 1 commitent and its opening? (2) Can we state SE of PCOM as
    above? I.e. with an adversary $\bdv$ who provides $\aux$ which determines
    PCOM challenge $z = \ro(\aux)$? Sounds fine -- no adversary should be able
    to efficiently find a $z$ that would fit it that way, but a formal reasoning
    is needed.}

  Now, since the polynomial commitment scheme is $(3, \eps)$-aux-simulation
  extractable, then there exists an extractor
  $\ext_{\bdv}(\srs_{\PCOM}, \qbdv, \rbdv)$ that outputs $\p{a}, \p{b}, \p{c}$.

  We now describe the extractor $\ext_\adv$ which makes a single call to
  $\ext_{\bdv}$: It gets as input $\srs, \srss$ from which it can compute
  $\srs_{{\PCOM}}$. The list $\qadv$ is constructed as above by $\bdv$ from the
  queries to its oracles, consequently, it allows to derive $\qbdv$.  The
  randomness $\radv$ is reused unchanged as $\rbdv$.
  $\ext_{\bdv}(\srs_{\PCOM}, \qbdv, \rbdv)$ outputs $\p{a}, \p{b}, \p{c}$ from
  which we decode the witness.

  % Since for $\plonk$ these are witness-encoding polynomials, one can reveal
  % $\inp$'s witness $\wit$.
  \comment{ To show that the extractor succeeds with overwheming probability, we
    relate the polynomials $\p{a}, \p{b}, \p{c}$ it produces to the coefficients
    $\p{a}', \p{b}', \p{c}'$ of the corresponding polynomial commitment produced
    by a related knowledge soundness algebraic adversary $\adv'$. $\adv'$ runs
    $\adv$ internally and simulates the signing oracle.

    When $\ext_\adv$ fails to extract a valid witness, one of two cases must
    hold: (i) either $(\p{a}, \p{b}, \p{c}) \neq (\p{a}', \p{b}', \p{c}')$ in
    which case we break the soundness of the polynomial commitment scheme or
    (ii), $\adv'$ breaks knowledge soundness.  }

  We now show that the extracted polynomials indeed encode witness $\wit'$ (this
  witness may differ from the witness $\wit$ provided by the prover) such that
  $\REL(\inp, \wit') = 1$. For that end, we introduce the following games.

  \ncase{$\game{0} \mapsto \game{1}$} Probability that $\game{1}$ and $\game{2}$
  return different values is \hl{zero} as the adversary $\adv$ gets the same
  input and oracle $\oraclesps$ and $\bdv$ composed with $\oraclespcom$ provide
  answers from the same distribution.
 
  \ncase{Game 2} In this game $\bdv$, instead of providing $\adv$ simulated
  proofs, outputs real proofs. That is, \michals{20.08}{Here comes description
    how $\bdv$ creates real proofs.}\michals{23.08}{Can $\bdv$ use randomness
    here?} \michals{23.08}{Does $\bdv$ use the pcom simulator here?}

 \ncase{$\game{1} \mapsto \game{2}$} Probability that $\game{1}$ and $\game{2}$
  return different values is $\epszk$ \hl{...}

  \ncase{Game 3} In this game we consider a set of algebraic adversary $\cdv_{\p{f}}(\srsPC)$
  that
  \begin{itemize}
  \item internally runs $\adv$ and $\bdv$,
  \item answers $\bdv$'s queries to $\oraclespcom$.
%  \item answers $\adv$, $\bdv$ queries to the random oracle by simulating it.
  \end{itemize}

  Let $\inp, \zkproof$ be the challenge instance--proof pair output by the
  adversary $\adv$ that contain commitments
  $\cp{a}, \cp{b}, \cp{z}, \cp{t_1}, \cp{t_2}, \cp{t_3}$ to polynomials
  $\p{a}, \p{b}, \p{z}, \p{t_1}, \p{t_2}, \p{t_3}$. Denote the set of
  commitments by $\p{C}$ and set of polynomials by $\p{F}$. For
  $\p{f} \in \p{F}$, adversary $\cdv_{\p{f}}$ outputs $\cp{\p{f}}$.

  Since $\cdv_{\p{f}}$ are algebraic, there exists extractors
  $\ext_{\cdv_{\p{f}}}$ that output $\p{f}$.
  
  \comment{ These commitments are output by $\cdv$. Since $\cdv$ is algebraic,
    there exists extractors $\ext_{\cdv, p{f}}(\srsPC)$ that output $\p{f}$ for
    $\p{f} \in \smallset{ \p{a}, \p{b}, \p{z}, \p{t_1}, \p{t_2},
      \p{t_3}}$.} \michals{20.08}{How to deal with RO here? I.e. we know that KZG
    is extractable in the AGM. However, does it allow for a RO?}

  \michals{23.08}{In the following we reduce to a state-restoration soundness of
    the PHP (i.e. the proof system is non interactive, instantiated with a
    random oracle)}

  \ncase{Game 4} In this game we consider a PHP adversary $\ddv$ that internally
  runs $\cdv_{\p{f}}$ and $\ext_{\cdv_{\p{f}}}$ for $\p{f} \in \p{F}$. This is
  done as follows
  \begin{itemize}
  \item Run $\cdv_{\p{f}}$ and $\ext_{\cdv_{\p{f}}}$ for
    $\p{f} \in \p{F}$.
  \item Parse polynomials $\p{a}, \p{b}, \p{c}$. If these
    polynomials encode witness $\wit'$, such that $\REL(\inp, \wit') = 1$ then
    the game returns 0.
  \item Else, send to $\PHP.\verifier$ the whole proof.
  \end{itemize}

  Since the proof is acceptable, yet the witness-carrying polynomials do not
  encode the valid witness, $\ddv$ breaks the state-restoriation knowledge
  soundness of $\PHP$.

    \michals{23.08}{In the following, old Game 4 the reduction goes to the
      interactive PHP proof.}
    \comment{
    \ncase{Game 4}  In this game we consider a PHP
    adversary $\ddv$ that internally runs $\cdv_{\p{f}}$ and
    $\ext_{\cdv_{\p{f}}}$ for $\p{f} \in \p{F}$. This is done as follows
  \begin{itemize}
  \item $\ddv$ runs $\cdv_{\p{a}}, \cdv_{\p{b}}, \cdv_{\p{c}}$ with
    $\ext_{\cdv_\p{a}}, \ext_{\cdv_\p{b}}, \ext_{\cdv_\p{c}}$ to learn
    polynomials $\p{a}, \p{b}, \p{c}$. If these polynomials encode witness
    $\wit'$, such that $\REL(\inp, \wit') = 1$ then the game returns 0. The
    polynomials are sent to $\PHP.\verifier$.
  \item On $\PHP.\verifier$ challenges $\beta, \gamma$, 
  \end{itemize}
  After it get polynomials $\p{a}, \p{b}, \p{z},
  \p{t_1}, \p{t_2}, \p{t_3}$ it plays the role of a PHP prover $\PHP.\prover$ while
  interacing with a PHP verifier $\PHP.\verifier$.
  }
  \michals{20.08}{Need to include possibility that $\ddv$ programs the random
    oracle for the guys inside.} 
  
  \qed
    \end{proof}
  






























\section{DRAFT-Notes on transformation to Universal Interactive Arguments}

\antonio{02.08}{Writing this note to convince myself that things aren't so easy as I
thought. Please could you tell me where the argument below should fail?}
In Lunar we define the notion of Universal Interactive Argument Systems in the SRS model
as a middle ground for our transformation from PHP to Universal SNARKs.

Here I want to show that we can reduce sim-ext of Universal Interactive Argument System
(UIA) to the "standard" security properties of UIA.
We assume the following properties from the UIA:
\begin{itemize}
	\item {\bf Straight-line extractability in the AGM.}
		There exists an ``extractor'' $\Ext$ (the name extractor might be slightly misleading, but I
		cannot find a better name for now) s.t. for any algebraic adversary $\adv$:
		\[
			\Prob[\srs,r]{
					b=1 \wedge (\inp,\wit)\not\in\ind:
					\begin{array}{l}
					\ind,\inp, \vec X \gets\adv(\srs),\\
					(\vec P,b) \gets \braket{\adv(\srs),\verifier(\Iphp(\ind),\inp;r)}\\
					\wit \gets \Ext(\inp,\ind,r,\vec X,\vec P)
					\end{array}
					}\in\negl
		\]
		In the probability above $r$ is uniformly random in $\bin^\secpar$, and $\vec P$ and
		$\vec X$	describe all the group elements output by the adversary as linear combination of
		$\srs$. $b=1$ means that the adversary convinces the verifier. Also, if $\inp$ or $\ind$
		do not contain any group elements then $\vec X$ is	empty. Finally, for simplicity we assumes that the adversary outputs only element in
		$\GG_1$ and $\GG_2$, so only linear combinations are allowed.
	\item {\bf honest-verifier zero-knowledge w/o trapdoor.}
		There exists a simulator $\sdv$ such that for any $\srs,\ind,\inp,\wit$ we have
		$\sdv(\srs,\ind,\inp)\equiv
		\braket{\prover(\srs,\ind,\inp,\wit),\verify(\srs,\Iphp(\ind),\inp)}$
		(For simplicity I am assuming perfectly close, to assume comp./statical closeness one should also
		take care of adaptive choice of $\inp,\ind$ w.r.t. $\srs$)

	\item {\bf (technical property) algebraic simulator.}
		The simulator additionally outputs a matrix $\vec T$ such that the output group elements
		are linear combinations of $\srs,\ind,\inp$

%	\item {\bf (technical property) unpredictability of honest prover .}
%		For any $\srs,\ind,\inp,\wit$ and let $\pmsg_1,\vmsg_1,\dots,\pmsg_m$ be a transcript for
%		$\braket{\prover(\srs,\ind,\inp,\wit),\verifier(\srs,\ind,\wit)}$ then	$\minH(\pmsg_1)\geq \secpar$.
%		(Thus also the simulated $\tilde\pmsg_1$ has a lot of min entropy)
\end{itemize}

Let $\adv$ be an adversary for the sim-ext of the UIA.
We wanna prove that:
\[
			\Prob[\srs,r]{
					b=1 \wedge (\inp,\wit)\not\in\ind:
					\begin{array}{l}
						\ind,\inp, \vec X \gets\adv^{SIM}(\srs),\\
					(\vec P,b) \gets \braket{\adv(\srs),\verifier(\Iphp(\ind),\inp;r)}\\
					\wit \gets \Ext(\inp,\ind,r,\vec X,\vec P)
					\end{array}
					}\in\negl
\]
where $SIM( \ind,\inp )$ produces a simulated (honest-verifier) proof for $\ind$ and $\inp$.
\antonio{02.08}{This notion of sim-ext plus a technical property that says that the first
message of the honest prover is unpredictable (it has high min-entropy) should imply
sim-sound for the compiled fiat-shamir protocol.}

Consider the algebraic adversary $\bdv$ described below:
\begin{itemize}
	\item Input is $\srs$ and it runs $\adv$ with input $\srs$, let $[\vec s]$ be (an
		initially empty)	dynamic vector that includes all the group elements seen by $\adv$ through calls to
		$SIM$.
%	\item Lazy simulate the random oracle (we assume $RO$ codomain is $\FF$ so verifier's
%		messages)
	\item On $\adv$ sending $\ind,\inp$ to $SIM$, notice that $\adv$ is algebraic, thus it
		additionally outputs $\vec X$ that describes $\ind,\inp$ as linear combinations of
		$\srs$ and $[\vec s]$:
		\begin{enumerate}
			\item Let $\vec S$ be a description of $[\vec s]$ as lin.comb of $\srs$ (set to empty
				matrix if first call).
				From $\vec X$ and $\vec S$ we can define a new matrix $\vec X'$ that describes
				$\ind,\inp$ as linear combs of $\srs$.
			\item Run $\sdv(\srs,\ind,\inp)$ and get a simulated transcript together with a matrix $\vec T$
				 that describes all the group elements in the simulated transcript as linear combinations of $\srs,\ind,\inp$.
					From $\vec X'$ and $\vec T$ we can compute a matrix $\vec T'$ that describes all
					the group elements in the transcript of the proof as linear combinations of the
					$\srs$. Update $\vec S$ concatenating the matrix $\vec T'$.
			\item Return the simulated transcript to $\adv$.
		\end{enumerate}
	\item On output $\ind,\inp,\vec X$ of $\adv$ define $\vec X'$ from $\vec X$ and $\vec S$
		and output $\ind,\inp,\vec X$ as first output for the sim-ext experiment.
	\item Similarly, follow the protocol proxing messages from/to $\adv$ and the external verifier.
		Eventually $\adv$ outputs $\vec T$, thus given $\vec S$ and $\vec T$ compute $\vec T'$
		that describes all the group elements in the transcript as linear combinations of the
		$\srs$.
\end{itemize}


Here I am being very sloppy with how we obtain, for example, $\vec X'$ from $\vec X$ and
$\vec S$.
More in detail, if 
$\vec y = (\vec M_0, \vec M_1) \pmtrx{\vec x\\\vec x'}$ and $\vec x' = \vec N \vec x$ then
easily $\vec y = \vec M' \vec x$ where $\vec M' = \vec M_0 + \vec M_1\vec N$.





\end{document}
